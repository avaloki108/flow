{
	RegisteredRule(rule=exploit_debt_overflow_manipulation, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, parentCVLDeclarationId=null, isCounted=true): true,
	RegisteredRule(rule=exploit_refund_steals_covered_debt, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, parentCVLDeclarationId=null, isCounted=true): true,
	RegisteredRule(rule=exploit_pause_debt_manipulation, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, parentCVLDeclarationId=null, isCounted=true): true,
	RegisteredRule(rule=exploit_uncovered_debt_calculation, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, parentCVLDeclarationId=null, isCounted=true): true,
	RegisteredRule(rule=exploit_deposit_front_running, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, parentCVLDeclarationId=null, isCounted=true): true,
	RegisteredRule(rule=exploit_time_based_debt_manipulation, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, parentCVLDeclarationId=null, isCounted=true): true,
	RegisteredRule(rule=exploit_depletion_time_calculation, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, parentCVLDeclarationId=null, isCounted=true): true,
	RegisteredRule(rule=envfreeFuncsStaticCheck, ruleType=spec.cvlast.SpecType$Group$StaticEnvFree@860ad929, parentCVLDeclarationId=null, isCounted=true): true,
	RegisteredRule(rule=getSnapshotDebtScaled(uint256), ruleType=Static(contractFunction=SablierFlow.getSnapshotDebtScaled(uint256 streamId) returns (uint256)), parentCVLDeclarationId=envfreeFuncsStaticCheck, isCounted=true): true,
	RegisteredRule(rule=getSender(uint256), ruleType=Static(contractFunction=SablierFlow.getSender(uint256 streamId) returns (address)), parentCVLDeclarationId=envfreeFuncsStaticCheck, isCounted=true): true,
	RegisteredRule(rule=getBalance(uint256), ruleType=Static(contractFunction=SablierFlow.getBalance(uint256 streamId) returns (uint128)), parentCVLDeclarationId=envfreeFuncsStaticCheck, isCounted=true): true,
	RegisteredRule(rule=getSnapshotTime(uint256), ruleType=Static(contractFunction=SablierFlow.getSnapshotTime(uint256 streamId) returns (uint40)), parentCVLDeclarationId=envfreeFuncsStaticCheck, isCounted=true): true,
	RegisteredRule(rule=isVoided(uint256), ruleType=Static(contractFunction=SablierFlow.isVoided(uint256 streamId) returns (bool)), parentCVLDeclarationId=envfreeFuncsStaticCheck, isCounted=true): true,
	RegisteredRule(rule=getRecipient(uint256), ruleType=Static(contractFunction=SablierFlow.getRecipient(uint256 streamId) returns (address)), parentCVLDeclarationId=envfreeFuncsStaticCheck, isCounted=true): true,
	RegisteredRule(rule=Assert_CRITICAL_EXPLOIT__Debt_decreased_over_time__overflow_detected_(CriticalExploits_spec_223_5), ruleType=AssertSpecFile(originalRule=CVLSingleRule(ruleIdentifier=exploit_time_based_debt_manipulation, range=CriticalExploits.spec:209:1, params=[uint256 streamId], description=, goodDescription=, block=[Declaration(range=CriticalExploits.spec:210:5, cvlType=env, id=e1, scope=(Spec file -> Rule exploit_time_based_debt_manipulation)), Declaration(range=CriticalExploits.spec:211:5, cvlType=env, id=e2, scope=(Spec file -> Rule exploit_time_based_debt_manipulation)), Assume(range=CriticalExploits.spec:213:5, exp=!(SablierFlow.isVoided(streamId)), description=null, scope=(Spec file -> Rule exploit_time_based_debt_manipulation), invariantPreCond=false, comesFromSpec=true), Assume(range=CriticalExploits.spec:214:5, exp=e2.block.timestamp > e1.block.timestamp, description=null, scope=(Spec file -> Rule exploit_time_based_debt_manipulation), invariantPreCond=false, comesFromSpec=true), Assume(range=CriticalExploits.spec:217:5, exp=to_mathint(e2.block.timestamp) - to_mathint(e1.block.timestamp) > 365 * 24 * 3600, description=null, scope=(Spec file -> Rule exploit_time_based_debt_manipulation), invariantPreCond=false, comesFromSpec=true), uint256 debt1 = SablierFlow.totalDebtOf(e1,streamId), uint256 debt2 = SablierFlow.totalDebtOf(e2,streamId), Assert(range=CriticalExploits.spec:223:5, exp=to_mathint(debt2) >= to_mathint(debt1), description="CRITICAL EXPLOIT: Debt decreased over time - overflow detected", scope=(Spec file -> Rule exploit_time_based_debt_manipulation), invariantPostCond=false)], ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, scope=(Spec file -> Rule exploit_time_based_debt_manipulation), methodParamFilters=MethodParamFilters(range=CriticalExploits.spec:209:1, scope=(Spec file -> Rule exploit_time_based_debt_manipulation), methodParamToFilter={}), ruleGenerationMeta=WithSanity(sanity=PRE_SANITY_CHECK), isSatisfyRule=false), assertId=1, assertMessage="CRITICAL EXPLOIT: Debt decreased over time - overflow detected", cvlCmdLoc=CriticalExploits.spec:223:5), parentCVLDeclarationId=exploit_time_based_debt_manipulation, isCounted=true): true,
	RegisteredRule(rule=Assert_CRITICAL_EXPLOIT__Debt_accounting_mismatch__manipulation_possible_(CriticalExploits_spec_157_5), ruleType=AssertSpecFile(originalRule=CVLSingleRule(ruleIdentifier=exploit_uncovered_debt_calculation, range=CriticalExploits.spec:146:1, params=[uint256 streamId], description=, goodDescription=, block=[Declaration(range=CriticalExploits.spec:147:5, cvlType=env, id=e, scope=(Spec file -> Rule exploit_uncovered_debt_calculation)), Assume(range=CriticalExploits.spec:149:5, exp=!(SablierFlow.isVoided(streamId)), description=null, scope=(Spec file -> Rule exploit_uncovered_debt_calculation), invariantPreCond=false, comesFromSpec=true), uint256 totalDebt = SablierFlow.totalDebtOf(e,streamId), uint128 covered = SablierFlow.coveredDebtOf(e,streamId), uint256 uncovered = SablierFlow.uncoveredDebtOf(e,streamId), uint128 balance = SablierFlow.getBalance(streamId), Assert(range=CriticalExploits.spec:157:5, exp=to_mathint(totalDebt) == to_mathint(covered) + to_mathint(uncovered), description="CRITICAL EXPLOIT: Debt accounting mismatch - manipulation possible", scope=(Spec file -> Rule exploit_uncovered_debt_calculation), invariantPostCond=false), Assert(range=CriticalExploits.spec:160:5, exp=covered <= balance, description="CRITICAL EXPLOIT: Covered debt exceeds balance - insolvency", scope=(Spec file -> Rule exploit_uncovered_debt_calculation), invariantPostCond=false), Assert(range=CriticalExploits.spec:163:5, exp=(uncovered > 0) => (balance < totalDebt), description="CRITICAL EXPLOIT: Uncovered debt exists but balance covers total debt", scope=(Spec file -> Rule exploit_uncovered_debt_calculation), invariantPostCond=false)], ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, scope=(Spec file -> Rule exploit_uncovered_debt_calculation), methodParamFilters=MethodParamFilters(range=CriticalExploits.spec:146:1, scope=(Spec file -> Rule exploit_uncovered_debt_calculation), methodParamToFilter={}), ruleGenerationMeta=WithSanity(sanity=PRE_SANITY_CHECK), isSatisfyRule=false), assertId=3, assertMessage="CRITICAL EXPLOIT: Debt accounting mismatch - manipulation possible", cvlCmdLoc=CriticalExploits.spec:157:5), parentCVLDeclarationId=exploit_uncovered_debt_calculation, isCounted=true): true,
	RegisteredRule(rule=Assert_CRITICAL_EXPLOIT__Depletion_time_calculation_allows_overdraft_(CriticalExploits_spec_251_9), ruleType=AssertSpecFile(originalRule=CVLSingleRule(ruleIdentifier=exploit_depletion_time_calculation, range=CriticalExploits.spec:231:1, params=[uint256 streamId], description=, goodDescription=, block=[Declaration(range=CriticalExploits.spec:232:5, cvlType=env, id=e, scope=(Spec file -> Rule exploit_depletion_time_calculation)), Assume(range=CriticalExploits.spec:234:5, exp=!(SablierFlow.isVoided(streamId)), description=null, scope=(Spec file -> Rule exploit_depletion_time_calculation), invariantPreCond=false, comesFromSpec=true), uint128 balance = SablierFlow.getBalance(streamId), Assume(range=CriticalExploits.spec:238:5, exp=SablierFlow.ongoingDebtScaledOf(e,streamId) > 0, description=null, scope=(Spec file -> Rule exploit_depletion_time_calculation), invariantPreCond=false, comesFromSpec=true), uint256 depletionTime = SablierFlow.depletionTimeOf(e,streamId), uint256 totalDebt = SablierFlow.totalDebtOf(e,streamId), Assume(range=CriticalExploits.spec:241:5, exp=balance > 0, description=null, scope=(Spec file -> Rule exploit_depletion_time_calculation), invariantPreCond=false, comesFromSpec=true), If(range=CriticalExploits.spec:245:5, cond=depletionTime > e.block.timestamp, thenCmd=Block(range=CriticalExploits.spec:245:44, block=[uint256 timeToDepletion = require_uint256(depletionTime - e.block.timestamp), Assert(range=CriticalExploits.spec:251:9, exp=to_mathint(balance) >= to_mathint(totalDebt), description="CRITICAL EXPLOIT: Depletion time calculation allows overdraft", scope=(Spec file -> Rule exploit_depletion_time_calculation -> If branch at CriticalExploits.spec:245:5 -> Block at CriticalExploits.spec:245:44), invariantPostCond=false)], scope=(Spec file -> Rule exploit_depletion_time_calculation -> If branch at CriticalExploits.spec:245:5 -> Block at CriticalExploits.spec:245:44)), elseCmd=Nop(range=CriticalExploits.spec:245:5, scope=(Spec file -> Rule exploit_depletion_time_calculation)), scope=(Spec file -> Rule exploit_depletion_time_calculation)), Assert(range=CriticalExploits.spec:253:5, exp=true, description=null, scope=(Spec file -> Rule exploit_depletion_time_calculation), invariantPostCond=false)], ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, scope=(Spec file -> Rule exploit_depletion_time_calculation), methodParamFilters=MethodParamFilters(range=CriticalExploits.spec:231:1, scope=(Spec file -> Rule exploit_depletion_time_calculation), methodParamToFilter={}), ruleGenerationMeta=WithSanity(sanity=PRE_SANITY_CHECK), isSatisfyRule=false), assertId=2, assertMessage="CRITICAL EXPLOIT: Depletion time calculation allows overdraft", cvlCmdLoc=CriticalExploits.spec:251:9), parentCVLDeclarationId=exploit_depletion_time_calculation, isCounted=true): true,
	RegisteredRule(rule=CheckAutoGeneratedAsserts, ruleType=AutoGenerated(originalRule=CVLSingleRule(ruleIdentifier=exploit_time_based_debt_manipulation, range=CriticalExploits.spec:209:1, params=[uint256 streamId], description=, goodDescription=, block=[Declaration(range=CriticalExploits.spec:210:5, cvlType=env, id=e1, scope=(Spec file -> Rule exploit_time_based_debt_manipulation)), Declaration(range=CriticalExploits.spec:211:5, cvlType=env, id=e2, scope=(Spec file -> Rule exploit_time_based_debt_manipulation)), Assume(range=CriticalExploits.spec:213:5, exp=!(SablierFlow.isVoided(streamId)), description=null, scope=(Spec file -> Rule exploit_time_based_debt_manipulation), invariantPreCond=false, comesFromSpec=true), Assume(range=CriticalExploits.spec:214:5, exp=e2.block.timestamp > e1.block.timestamp, description=null, scope=(Spec file -> Rule exploit_time_based_debt_manipulation), invariantPreCond=false, comesFromSpec=true), Assume(range=CriticalExploits.spec:217:5, exp=to_mathint(e2.block.timestamp) - to_mathint(e1.block.timestamp) > 365 * 24 * 3600, description=null, scope=(Spec file -> Rule exploit_time_based_debt_manipulation), invariantPreCond=false, comesFromSpec=true), uint256 debt1 = SablierFlow.totalDebtOf(e1,streamId), uint256 debt2 = SablierFlow.totalDebtOf(e2,streamId), Assert(range=CriticalExploits.spec:223:5, exp=to_mathint(debt2) >= to_mathint(debt1), description="CRITICAL EXPLOIT: Debt decreased over time - overflow detected", scope=(Spec file -> Rule exploit_time_based_debt_manipulation), invariantPostCond=false)], ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, scope=(Spec file -> Rule exploit_time_based_debt_manipulation), methodParamFilters=MethodParamFilters(range=CriticalExploits.spec:209:1, scope=(Spec file -> Rule exploit_time_based_debt_manipulation), methodParamToFilter={}), ruleGenerationMeta=WithSanity(sanity=PRE_SANITY_CHECK), isSatisfyRule=false)), parentCVLDeclarationId=exploit_time_based_debt_manipulation, isCounted=true): true,
	RegisteredRule(rule=Assert_CRITICAL_EXPLOIT__Covered_debt_exceeds_balance__insolvency_(CriticalExploits_spec_160_5), ruleType=AssertSpecFile(originalRule=CVLSingleRule(ruleIdentifier=exploit_uncovered_debt_calculation, range=CriticalExploits.spec:146:1, params=[uint256 streamId], description=, goodDescription=, block=[Declaration(range=CriticalExploits.spec:147:5, cvlType=env, id=e, scope=(Spec file -> Rule exploit_uncovered_debt_calculation)), Assume(range=CriticalExploits.spec:149:5, exp=!(SablierFlow.isVoided(streamId)), description=null, scope=(Spec file -> Rule exploit_uncovered_debt_calculation), invariantPreCond=false, comesFromSpec=true), uint256 totalDebt = SablierFlow.totalDebtOf(e,streamId), uint128 covered = SablierFlow.coveredDebtOf(e,streamId), uint256 uncovered = SablierFlow.uncoveredDebtOf(e,streamId), uint128 balance = SablierFlow.getBalance(streamId), Assert(range=CriticalExploits.spec:157:5, exp=to_mathint(totalDebt) == to_mathint(covered) + to_mathint(uncovered), description="CRITICAL EXPLOIT: Debt accounting mismatch - manipulation possible", scope=(Spec file -> Rule exploit_uncovered_debt_calculation), invariantPostCond=false), Assert(range=CriticalExploits.spec:160:5, exp=covered <= balance, description="CRITICAL EXPLOIT: Covered debt exceeds balance - insolvency", scope=(Spec file -> Rule exploit_uncovered_debt_calculation), invariantPostCond=false), Assert(range=CriticalExploits.spec:163:5, exp=(uncovered > 0) => (balance < totalDebt), description="CRITICAL EXPLOIT: Uncovered debt exists but balance covers total debt", scope=(Spec file -> Rule exploit_uncovered_debt_calculation), invariantPostCond=false)], ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, scope=(Spec file -> Rule exploit_uncovered_debt_calculation), methodParamFilters=MethodParamFilters(range=CriticalExploits.spec:146:1, scope=(Spec file -> Rule exploit_uncovered_debt_calculation), methodParamToFilter={}), ruleGenerationMeta=WithSanity(sanity=PRE_SANITY_CHECK), isSatisfyRule=false), assertId=5, assertMessage="CRITICAL EXPLOIT: Covered debt exceeds balance - insolvency", cvlCmdLoc=CriticalExploits.spec:160:5), parentCVLDeclarationId=exploit_uncovered_debt_calculation, isCounted=true): true,
	RegisteredRule(rule=Assert_true_(CriticalExploits_spec_253_5), ruleType=AssertSpecFile(originalRule=CVLSingleRule(ruleIdentifier=exploit_depletion_time_calculation, range=CriticalExploits.spec:231:1, params=[uint256 streamId], description=, goodDescription=, block=[Declaration(range=CriticalExploits.spec:232:5, cvlType=env, id=e, scope=(Spec file -> Rule exploit_depletion_time_calculation)), Assume(range=CriticalExploits.spec:234:5, exp=!(SablierFlow.isVoided(streamId)), description=null, scope=(Spec file -> Rule exploit_depletion_time_calculation), invariantPreCond=false, comesFromSpec=true), uint128 balance = SablierFlow.getBalance(streamId), Assume(range=CriticalExploits.spec:238:5, exp=SablierFlow.ongoingDebtScaledOf(e,streamId) > 0, description=null, scope=(Spec file -> Rule exploit_depletion_time_calculation), invariantPreCond=false, comesFromSpec=true), uint256 depletionTime = SablierFlow.depletionTimeOf(e,streamId), uint256 totalDebt = SablierFlow.totalDebtOf(e,streamId), Assume(range=CriticalExploits.spec:241:5, exp=balance > 0, description=null, scope=(Spec file -> Rule exploit_depletion_time_calculation), invariantPreCond=false, comesFromSpec=true), If(range=CriticalExploits.spec:245:5, cond=depletionTime > e.block.timestamp, thenCmd=Block(range=CriticalExploits.spec:245:44, block=[uint256 timeToDepletion = require_uint256(depletionTime - e.block.timestamp), Assert(range=CriticalExploits.spec:251:9, exp=to_mathint(balance) >= to_mathint(totalDebt), description="CRITICAL EXPLOIT: Depletion time calculation allows overdraft", scope=(Spec file -> Rule exploit_depletion_time_calculation -> If branch at CriticalExploits.spec:245:5 -> Block at CriticalExploits.spec:245:44), invariantPostCond=false)], scope=(Spec file -> Rule exploit_depletion_time_calculation -> If branch at CriticalExploits.spec:245:5 -> Block at CriticalExploits.spec:245:44)), elseCmd=Nop(range=CriticalExploits.spec:245:5, scope=(Spec file -> Rule exploit_depletion_time_calculation)), scope=(Spec file -> Rule exploit_depletion_time_calculation)), Assert(range=CriticalExploits.spec:253:5, exp=true, description=null, scope=(Spec file -> Rule exploit_depletion_time_calculation), invariantPostCond=false)], ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, scope=(Spec file -> Rule exploit_depletion_time_calculation), methodParamFilters=MethodParamFilters(range=CriticalExploits.spec:231:1, scope=(Spec file -> Rule exploit_depletion_time_calculation), methodParamToFilter={}), ruleGenerationMeta=WithSanity(sanity=PRE_SANITY_CHECK), isSatisfyRule=false), assertId=4, assertMessage=true, cvlCmdLoc=CriticalExploits.spec:253:5), parentCVLDeclarationId=exploit_depletion_time_calculation, isCounted=true): true,
	RegisteredRule(rule=Assert_CRITICAL_EXPLOIT__Uncovered_debt_exists_but_balance_covers_total_debt_(CriticalExploits_spec_163_5), ruleType=AssertSpecFile(originalRule=CVLSingleRule(ruleIdentifier=exploit_uncovered_debt_calculation, range=CriticalExploits.spec:146:1, params=[uint256 streamId], description=, goodDescription=, block=[Declaration(range=CriticalExploits.spec:147:5, cvlType=env, id=e, scope=(Spec file -> Rule exploit_uncovered_debt_calculation)), Assume(range=CriticalExploits.spec:149:5, exp=!(SablierFlow.isVoided(streamId)), description=null, scope=(Spec file -> Rule exploit_uncovered_debt_calculation), invariantPreCond=false, comesFromSpec=true), uint256 totalDebt = SablierFlow.totalDebtOf(e,streamId), uint128 covered = SablierFlow.coveredDebtOf(e,streamId), uint256 uncovered = SablierFlow.uncoveredDebtOf(e,streamId), uint128 balance = SablierFlow.getBalance(streamId), Assert(range=CriticalExploits.spec:157:5, exp=to_mathint(totalDebt) == to_mathint(covered) + to_mathint(uncovered), description="CRITICAL EXPLOIT: Debt accounting mismatch - manipulation possible", scope=(Spec file -> Rule exploit_uncovered_debt_calculation), invariantPostCond=false), Assert(range=CriticalExploits.spec:160:5, exp=covered <= balance, description="CRITICAL EXPLOIT: Covered debt exceeds balance - insolvency", scope=(Spec file -> Rule exploit_uncovered_debt_calculation), invariantPostCond=false), Assert(range=CriticalExploits.spec:163:5, exp=(uncovered > 0) => (balance < totalDebt), description="CRITICAL EXPLOIT: Uncovered debt exists but balance covers total debt", scope=(Spec file -> Rule exploit_uncovered_debt_calculation), invariantPostCond=false)], ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, scope=(Spec file -> Rule exploit_uncovered_debt_calculation), methodParamFilters=MethodParamFilters(range=CriticalExploits.spec:146:1, scope=(Spec file -> Rule exploit_uncovered_debt_calculation), methodParamToFilter={}), ruleGenerationMeta=WithSanity(sanity=PRE_SANITY_CHECK), isSatisfyRule=false), assertId=6, assertMessage="CRITICAL EXPLOIT: Uncovered debt exists but balance covers total debt", cvlCmdLoc=CriticalExploits.spec:163:5), parentCVLDeclarationId=exploit_uncovered_debt_calculation, isCounted=true): true,
	RegisteredRule(rule=CheckAutoGeneratedAsserts, ruleType=AutoGenerated(originalRule=CVLSingleRule(ruleIdentifier=exploit_depletion_time_calculation, range=CriticalExploits.spec:231:1, params=[uint256 streamId], description=, goodDescription=, block=[Declaration(range=CriticalExploits.spec:232:5, cvlType=env, id=e, scope=(Spec file -> Rule exploit_depletion_time_calculation)), Assume(range=CriticalExploits.spec:234:5, exp=!(SablierFlow.isVoided(streamId)), description=null, scope=(Spec file -> Rule exploit_depletion_time_calculation), invariantPreCond=false, comesFromSpec=true), uint128 balance = SablierFlow.getBalance(streamId), Assume(range=CriticalExploits.spec:238:5, exp=SablierFlow.ongoingDebtScaledOf(e,streamId) > 0, description=null, scope=(Spec file -> Rule exploit_depletion_time_calculation), invariantPreCond=false, comesFromSpec=true), uint256 depletionTime = SablierFlow.depletionTimeOf(e,streamId), uint256 totalDebt = SablierFlow.totalDebtOf(e,streamId), Assume(range=CriticalExploits.spec:241:5, exp=balance > 0, description=null, scope=(Spec file -> Rule exploit_depletion_time_calculation), invariantPreCond=false, comesFromSpec=true), If(range=CriticalExploits.spec:245:5, cond=depletionTime > e.block.timestamp, thenCmd=Block(range=CriticalExploits.spec:245:44, block=[uint256 timeToDepletion = require_uint256(depletionTime - e.block.timestamp), Assert(range=CriticalExploits.spec:251:9, exp=to_mathint(balance) >= to_mathint(totalDebt), description="CRITICAL EXPLOIT: Depletion time calculation allows overdraft", scope=(Spec file -> Rule exploit_depletion_time_calculation -> If branch at CriticalExploits.spec:245:5 -> Block at CriticalExploits.spec:245:44), invariantPostCond=false)], scope=(Spec file -> Rule exploit_depletion_time_calculation -> If branch at CriticalExploits.spec:245:5 -> Block at CriticalExploits.spec:245:44)), elseCmd=Nop(range=CriticalExploits.spec:245:5, scope=(Spec file -> Rule exploit_depletion_time_calculation)), scope=(Spec file -> Rule exploit_depletion_time_calculation)), Assert(range=CriticalExploits.spec:253:5, exp=true, description=null, scope=(Spec file -> Rule exploit_depletion_time_calculation), invariantPostCond=false)], ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, scope=(Spec file -> Rule exploit_depletion_time_calculation), methodParamFilters=MethodParamFilters(range=CriticalExploits.spec:231:1, scope=(Spec file -> Rule exploit_depletion_time_calculation), methodParamToFilter={}), ruleGenerationMeta=WithSanity(sanity=PRE_SANITY_CHECK), isSatisfyRule=false)), parentCVLDeclarationId=exploit_depletion_time_calculation, isCounted=true): true,
	RegisteredRule(rule=CheckAutoGeneratedAsserts, ruleType=AutoGenerated(originalRule=CVLSingleRule(ruleIdentifier=exploit_uncovered_debt_calculation, range=CriticalExploits.spec:146:1, params=[uint256 streamId], description=, goodDescription=, block=[Declaration(range=CriticalExploits.spec:147:5, cvlType=env, id=e, scope=(Spec file -> Rule exploit_uncovered_debt_calculation)), Assume(range=CriticalExploits.spec:149:5, exp=!(SablierFlow.isVoided(streamId)), description=null, scope=(Spec file -> Rule exploit_uncovered_debt_calculation), invariantPreCond=false, comesFromSpec=true), uint256 totalDebt = SablierFlow.totalDebtOf(e,streamId), uint128 covered = SablierFlow.coveredDebtOf(e,streamId), uint256 uncovered = SablierFlow.uncoveredDebtOf(e,streamId), uint128 balance = SablierFlow.getBalance(streamId), Assert(range=CriticalExploits.spec:157:5, exp=to_mathint(totalDebt) == to_mathint(covered) + to_mathint(uncovered), description="CRITICAL EXPLOIT: Debt accounting mismatch - manipulation possible", scope=(Spec file -> Rule exploit_uncovered_debt_calculation), invariantPostCond=false), Assert(range=CriticalExploits.spec:160:5, exp=covered <= balance, description="CRITICAL EXPLOIT: Covered debt exceeds balance - insolvency", scope=(Spec file -> Rule exploit_uncovered_debt_calculation), invariantPostCond=false), Assert(range=CriticalExploits.spec:163:5, exp=(uncovered > 0) => (balance < totalDebt), description="CRITICAL EXPLOIT: Uncovered debt exists but balance covers total debt", scope=(Spec file -> Rule exploit_uncovered_debt_calculation), invariantPostCond=false)], ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, scope=(Spec file -> Rule exploit_uncovered_debt_calculation), methodParamFilters=MethodParamFilters(range=CriticalExploits.spec:146:1, scope=(Spec file -> Rule exploit_uncovered_debt_calculation), methodParamToFilter={}), ruleGenerationMeta=WithSanity(sanity=PRE_SANITY_CHECK), isSatisfyRule=false)), parentCVLDeclarationId=exploit_uncovered_debt_calculation, isCounted=true): true,
	RegisteredRule(rule=Assert_CRITICAL_EXPLOIT__Pause_decreased_total_debt__manipulation_(CriticalExploits_spec_138_5), ruleType=AssertSpecFile(originalRule=CVLSingleRule(ruleIdentifier=exploit_pause_debt_manipulation, range=CriticalExploits.spec:125:1, params=[uint256 streamId], description=, goodDescription=, block=[Declaration(range=CriticalExploits.spec:126:5, cvlType=env, id=e1, scope=(Spec file -> Rule exploit_pause_debt_manipulation)), Assume(range=CriticalExploits.spec:127:5, exp=!(SablierFlow.isVoided(streamId)), description=null, scope=(Spec file -> Rule exploit_pause_debt_manipulation), invariantPreCond=false, comesFromSpec=true), uint256 totalDebtBefore = SablierFlow.totalDebtOf(e1,streamId), uint128 coveredBefore = SablierFlow.coveredDebtOf(e1,streamId), uint128 balanceBefore = SablierFlow.getBalance(streamId), Apply(range=CriticalExploits.spec:134:5, exp=SablierFlow.pause(e1,streamId), scope=(Spec file -> Rule exploit_pause_debt_manipulation)), uint256 debtAfterPause = SablierFlow.totalDebtOf(e1,streamId), Assert(range=CriticalExploits.spec:138:5, exp=debtAfterPause >= totalDebtBefore, description="CRITICAL EXPLOIT: Pause decreased total debt - manipulation", scope=(Spec file -> Rule exploit_pause_debt_manipulation), invariantPostCond=false)], ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, scope=(Spec file -> Rule exploit_pause_debt_manipulation), methodParamFilters=MethodParamFilters(range=CriticalExploits.spec:125:1, scope=(Spec file -> Rule exploit_pause_debt_manipulation), methodParamToFilter={}), ruleGenerationMeta=WithSanity(sanity=PRE_SANITY_CHECK), isSatisfyRule=false), assertId=7, assertMessage="CRITICAL EXPLOIT: Pause decreased total debt - manipulation", cvlCmdLoc=CriticalExploits.spec:138:5), parentCVLDeclarationId=exploit_pause_debt_manipulation, isCounted=true): true,
	RegisteredRule(rule=CheckAutoGeneratedAsserts, ruleType=AutoGenerated(originalRule=CVLSingleRule(ruleIdentifier=exploit_pause_debt_manipulation, range=CriticalExploits.spec:125:1, params=[uint256 streamId], description=, goodDescription=, block=[Declaration(range=CriticalExploits.spec:126:5, cvlType=env, id=e1, scope=(Spec file -> Rule exploit_pause_debt_manipulation)), Assume(range=CriticalExploits.spec:127:5, exp=!(SablierFlow.isVoided(streamId)), description=null, scope=(Spec file -> Rule exploit_pause_debt_manipulation), invariantPreCond=false, comesFromSpec=true), uint256 totalDebtBefore = SablierFlow.totalDebtOf(e1,streamId), uint128 coveredBefore = SablierFlow.coveredDebtOf(e1,streamId), uint128 balanceBefore = SablierFlow.getBalance(streamId), Apply(range=CriticalExploits.spec:134:5, exp=SablierFlow.pause(e1,streamId), scope=(Spec file -> Rule exploit_pause_debt_manipulation)), uint256 debtAfterPause = SablierFlow.totalDebtOf(e1,streamId), Assert(range=CriticalExploits.spec:138:5, exp=debtAfterPause >= totalDebtBefore, description="CRITICAL EXPLOIT: Pause decreased total debt - manipulation", scope=(Spec file -> Rule exploit_pause_debt_manipulation), invariantPostCond=false)], ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, scope=(Spec file -> Rule exploit_pause_debt_manipulation), methodParamFilters=MethodParamFilters(range=CriticalExploits.spec:125:1, scope=(Spec file -> Rule exploit_pause_debt_manipulation), methodParamToFilter={}), ruleGenerationMeta=WithSanity(sanity=PRE_SANITY_CHECK), isSatisfyRule=false)), parentCVLDeclarationId=exploit_pause_debt_manipulation, isCounted=true): true,
	RegisteredRule(rule=Assert_CRITICAL_EXPLOIT__Refund_stole_covered_debt_from_recipient_(CriticalExploits_spec_111_9), ruleType=AssertSpecFile(originalRule=CVLSingleRule(ruleIdentifier=exploit_refund_steals_covered_debt, range=CriticalExploits.spec:87:1, params=[uint256 streamId], description=, goodDescription=, block=[Declaration(range=CriticalExploits.spec:88:5, cvlType=env, id=e, scope=(Spec file -> Rule exploit_refund_steals_covered_debt)), Assume(range=CriticalExploits.spec:90:5, exp=!(SablierFlow.isVoided(streamId)), description=null, scope=(Spec file -> Rule exploit_refund_steals_covered_debt), invariantPreCond=false, comesFromSpec=true), uint128 coveredBefore = SablierFlow.coveredDebtOf(e,streamId), uint128 balanceBefore = SablierFlow.getBalance(streamId), uint128 refundableBefore = SablierFlow.refundableAmountOf(e,streamId), Assume(range=CriticalExploits.spec:96:5, exp=coveredBefore > 0, description=null, scope=(Spec file -> Rule exploit_refund_steals_covered_debt), invariantPreCond=false, comesFromSpec=true), Assume(range=CriticalExploits.spec:97:5, exp=balanceBefore > coveredBefore, description=null, scope=(Spec file -> Rule exploit_refund_steals_covered_debt), invariantPreCond=false, comesFromSpec=true), uint128 refundAmount = refundableBefore, Assume(range=CriticalExploits.spec:102:5, exp=refundAmount > 0, description=null, scope=(Spec file -> Rule exploit_refund_steals_covered_debt), invariantPreCond=false, comesFromSpec=true), Apply(range=CriticalExploits.spec:104:5, exp=SablierFlow.refund(e,streamId,refundAmount) could_revert, scope=(Spec file -> Rule exploit_refund_steals_covered_debt)), If(range=CriticalExploits.spec:106:5, cond=!(lastReverted), thenCmd=Block(range=CriticalExploits.spec:106:24, block=[uint128 coveredAfter = SablierFlow.coveredDebtOf(e,streamId), uint128 balanceAfter = SablierFlow.getBalance(streamId), Assert(range=CriticalExploits.spec:111:9, exp=coveredAfter >= coveredBefore || balanceAfter < coveredBefore, description="CRITICAL EXPLOIT: Refund stole covered debt from recipient", scope=(Spec file -> Rule exploit_refund_steals_covered_debt -> If branch at CriticalExploits.spec:106:5 -> Block at CriticalExploits.spec:106:24), invariantPostCond=false), Assert(range=CriticalExploits.spec:114:9, exp=to_mathint(balanceBefore) - to_mathint(coveredBefore) >= to_mathint(balanceAfter) - to_mathint(coveredAfter), description="CRITICAL EXPLOIT: Refund extracted more than excess balance", scope=(Spec file -> Rule exploit_refund_steals_covered_debt -> If branch at CriticalExploits.spec:106:5 -> Block at CriticalExploits.spec:106:24), invariantPostCond=false)], scope=(Spec file -> Rule exploit_refund_steals_covered_debt -> If branch at CriticalExploits.spec:106:5 -> Block at CriticalExploits.spec:106:24)), elseCmd=Nop(range=CriticalExploits.spec:106:5, scope=(Spec file -> Rule exploit_refund_steals_covered_debt)), scope=(Spec file -> Rule exploit_refund_steals_covered_debt)), Assert(range=CriticalExploits.spec:116:5, exp=true, description=null, scope=(Spec file -> Rule exploit_refund_steals_covered_debt), invariantPostCond=false)], ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, scope=(Spec file -> Rule exploit_refund_steals_covered_debt), methodParamFilters=MethodParamFilters(range=CriticalExploits.spec:87:1, scope=(Spec file -> Rule exploit_refund_steals_covered_debt), methodParamToFilter={}), ruleGenerationMeta=WithSanity(sanity=PRE_SANITY_CHECK), isSatisfyRule=false), assertId=8, assertMessage="CRITICAL EXPLOIT: Refund stole covered debt from recipient", cvlCmdLoc=CriticalExploits.spec:111:9), parentCVLDeclarationId=exploit_refund_steals_covered_debt, isCounted=true): true,
	RegisteredRule(rule=Assert_CRITICAL_EXPLOIT__Refund_extracted_more_than_excess_balance_(CriticalExploits_spec_114_9), ruleType=AssertSpecFile(originalRule=CVLSingleRule(ruleIdentifier=exploit_refund_steals_covered_debt, range=CriticalExploits.spec:87:1, params=[uint256 streamId], description=, goodDescription=, block=[Declaration(range=CriticalExploits.spec:88:5, cvlType=env, id=e, scope=(Spec file -> Rule exploit_refund_steals_covered_debt)), Assume(range=CriticalExploits.spec:90:5, exp=!(SablierFlow.isVoided(streamId)), description=null, scope=(Spec file -> Rule exploit_refund_steals_covered_debt), invariantPreCond=false, comesFromSpec=true), uint128 coveredBefore = SablierFlow.coveredDebtOf(e,streamId), uint128 balanceBefore = SablierFlow.getBalance(streamId), uint128 refundableBefore = SablierFlow.refundableAmountOf(e,streamId), Assume(range=CriticalExploits.spec:96:5, exp=coveredBefore > 0, description=null, scope=(Spec file -> Rule exploit_refund_steals_covered_debt), invariantPreCond=false, comesFromSpec=true), Assume(range=CriticalExploits.spec:97:5, exp=balanceBefore > coveredBefore, description=null, scope=(Spec file -> Rule exploit_refund_steals_covered_debt), invariantPreCond=false, comesFromSpec=true), uint128 refundAmount = refundableBefore, Assume(range=CriticalExploits.spec:102:5, exp=refundAmount > 0, description=null, scope=(Spec file -> Rule exploit_refund_steals_covered_debt), invariantPreCond=false, comesFromSpec=true), Apply(range=CriticalExploits.spec:104:5, exp=SablierFlow.refund(e,streamId,refundAmount) could_revert, scope=(Spec file -> Rule exploit_refund_steals_covered_debt)), If(range=CriticalExploits.spec:106:5, cond=!(lastReverted), thenCmd=Block(range=CriticalExploits.spec:106:24, block=[uint128 coveredAfter = SablierFlow.coveredDebtOf(e,streamId), uint128 balanceAfter = SablierFlow.getBalance(streamId), Assert(range=CriticalExploits.spec:111:9, exp=coveredAfter >= coveredBefore || balanceAfter < coveredBefore, description="CRITICAL EXPLOIT: Refund stole covered debt from recipient", scope=(Spec file -> Rule exploit_refund_steals_covered_debt -> If branch at CriticalExploits.spec:106:5 -> Block at CriticalExploits.spec:106:24), invariantPostCond=false), Assert(range=CriticalExploits.spec:114:9, exp=to_mathint(balanceBefore) - to_mathint(coveredBefore) >= to_mathint(balanceAfter) - to_mathint(coveredAfter), description="CRITICAL EXPLOIT: Refund extracted more than excess balance", scope=(Spec file -> Rule exploit_refund_steals_covered_debt -> If branch at CriticalExploits.spec:106:5 -> Block at CriticalExploits.spec:106:24), invariantPostCond=false)], scope=(Spec file -> Rule exploit_refund_steals_covered_debt -> If branch at CriticalExploits.spec:106:5 -> Block at CriticalExploits.spec:106:24)), elseCmd=Nop(range=CriticalExploits.spec:106:5, scope=(Spec file -> Rule exploit_refund_steals_covered_debt)), scope=(Spec file -> Rule exploit_refund_steals_covered_debt)), Assert(range=CriticalExploits.spec:116:5, exp=true, description=null, scope=(Spec file -> Rule exploit_refund_steals_covered_debt), invariantPostCond=false)], ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, scope=(Spec file -> Rule exploit_refund_steals_covered_debt), methodParamFilters=MethodParamFilters(range=CriticalExploits.spec:87:1, scope=(Spec file -> Rule exploit_refund_steals_covered_debt), methodParamToFilter={}), ruleGenerationMeta=WithSanity(sanity=PRE_SANITY_CHECK), isSatisfyRule=false), assertId=9, assertMessage="CRITICAL EXPLOIT: Refund extracted more than excess balance", cvlCmdLoc=CriticalExploits.spec:114:9), parentCVLDeclarationId=exploit_refund_steals_covered_debt, isCounted=true): true,
	RegisteredRule(rule=Assert_true_(CriticalExploits_spec_116_5), ruleType=AssertSpecFile(originalRule=CVLSingleRule(ruleIdentifier=exploit_refund_steals_covered_debt, range=CriticalExploits.spec:87:1, params=[uint256 streamId], description=, goodDescription=, block=[Declaration(range=CriticalExploits.spec:88:5, cvlType=env, id=e, scope=(Spec file -> Rule exploit_refund_steals_covered_debt)), Assume(range=CriticalExploits.spec:90:5, exp=!(SablierFlow.isVoided(streamId)), description=null, scope=(Spec file -> Rule exploit_refund_steals_covered_debt), invariantPreCond=false, comesFromSpec=true), uint128 coveredBefore = SablierFlow.coveredDebtOf(e,streamId), uint128 balanceBefore = SablierFlow.getBalance(streamId), uint128 refundableBefore = SablierFlow.refundableAmountOf(e,streamId), Assume(range=CriticalExploits.spec:96:5, exp=coveredBefore > 0, description=null, scope=(Spec file -> Rule exploit_refund_steals_covered_debt), invariantPreCond=false, comesFromSpec=true), Assume(range=CriticalExploits.spec:97:5, exp=balanceBefore > coveredBefore, description=null, scope=(Spec file -> Rule exploit_refund_steals_covered_debt), invariantPreCond=false, comesFromSpec=true), uint128 refundAmount = refundableBefore, Assume(range=CriticalExploits.spec:102:5, exp=refundAmount > 0, description=null, scope=(Spec file -> Rule exploit_refund_steals_covered_debt), invariantPreCond=false, comesFromSpec=true), Apply(range=CriticalExploits.spec:104:5, exp=SablierFlow.refund(e,streamId,refundAmount) could_revert, scope=(Spec file -> Rule exploit_refund_steals_covered_debt)), If(range=CriticalExploits.spec:106:5, cond=!(lastReverted), thenCmd=Block(range=CriticalExploits.spec:106:24, block=[uint128 coveredAfter = SablierFlow.coveredDebtOf(e,streamId), uint128 balanceAfter = SablierFlow.getBalance(streamId), Assert(range=CriticalExploits.spec:111:9, exp=coveredAfter >= coveredBefore || balanceAfter < coveredBefore, description="CRITICAL EXPLOIT: Refund stole covered debt from recipient", scope=(Spec file -> Rule exploit_refund_steals_covered_debt -> If branch at CriticalExploits.spec:106:5 -> Block at CriticalExploits.spec:106:24), invariantPostCond=false), Assert(range=CriticalExploits.spec:114:9, exp=to_mathint(balanceBefore) - to_mathint(coveredBefore) >= to_mathint(balanceAfter) - to_mathint(coveredAfter), description="CRITICAL EXPLOIT: Refund extracted more than excess balance", scope=(Spec file -> Rule exploit_refund_steals_covered_debt -> If branch at CriticalExploits.spec:106:5 -> Block at CriticalExploits.spec:106:24), invariantPostCond=false)], scope=(Spec file -> Rule exploit_refund_steals_covered_debt -> If branch at CriticalExploits.spec:106:5 -> Block at CriticalExploits.spec:106:24)), elseCmd=Nop(range=CriticalExploits.spec:106:5, scope=(Spec file -> Rule exploit_refund_steals_covered_debt)), scope=(Spec file -> Rule exploit_refund_steals_covered_debt)), Assert(range=CriticalExploits.spec:116:5, exp=true, description=null, scope=(Spec file -> Rule exploit_refund_steals_covered_debt), invariantPostCond=false)], ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, scope=(Spec file -> Rule exploit_refund_steals_covered_debt), methodParamFilters=MethodParamFilters(range=CriticalExploits.spec:87:1, scope=(Spec file -> Rule exploit_refund_steals_covered_debt), methodParamToFilter={}), ruleGenerationMeta=WithSanity(sanity=PRE_SANITY_CHECK), isSatisfyRule=false), assertId=10, assertMessage=true, cvlCmdLoc=CriticalExploits.spec:116:5), parentCVLDeclarationId=exploit_refund_steals_covered_debt, isCounted=true): true,
	RegisteredRule(rule=CheckAutoGeneratedAsserts, ruleType=AutoGenerated(originalRule=CVLSingleRule(ruleIdentifier=exploit_refund_steals_covered_debt, range=CriticalExploits.spec:87:1, params=[uint256 streamId], description=, goodDescription=, block=[Declaration(range=CriticalExploits.spec:88:5, cvlType=env, id=e, scope=(Spec file -> Rule exploit_refund_steals_covered_debt)), Assume(range=CriticalExploits.spec:90:5, exp=!(SablierFlow.isVoided(streamId)), description=null, scope=(Spec file -> Rule exploit_refund_steals_covered_debt), invariantPreCond=false, comesFromSpec=true), uint128 coveredBefore = SablierFlow.coveredDebtOf(e,streamId), uint128 balanceBefore = SablierFlow.getBalance(streamId), uint128 refundableBefore = SablierFlow.refundableAmountOf(e,streamId), Assume(range=CriticalExploits.spec:96:5, exp=coveredBefore > 0, description=null, scope=(Spec file -> Rule exploit_refund_steals_covered_debt), invariantPreCond=false, comesFromSpec=true), Assume(range=CriticalExploits.spec:97:5, exp=balanceBefore > coveredBefore, description=null, scope=(Spec file -> Rule exploit_refund_steals_covered_debt), invariantPreCond=false, comesFromSpec=true), uint128 refundAmount = refundableBefore, Assume(range=CriticalExploits.spec:102:5, exp=refundAmount > 0, description=null, scope=(Spec file -> Rule exploit_refund_steals_covered_debt), invariantPreCond=false, comesFromSpec=true), Apply(range=CriticalExploits.spec:104:5, exp=SablierFlow.refund(e,streamId,refundAmount) could_revert, scope=(Spec file -> Rule exploit_refund_steals_covered_debt)), If(range=CriticalExploits.spec:106:5, cond=!(lastReverted), thenCmd=Block(range=CriticalExploits.spec:106:24, block=[uint128 coveredAfter = SablierFlow.coveredDebtOf(e,streamId), uint128 balanceAfter = SablierFlow.getBalance(streamId), Assert(range=CriticalExploits.spec:111:9, exp=coveredAfter >= coveredBefore || balanceAfter < coveredBefore, description="CRITICAL EXPLOIT: Refund stole covered debt from recipient", scope=(Spec file -> Rule exploit_refund_steals_covered_debt -> If branch at CriticalExploits.spec:106:5 -> Block at CriticalExploits.spec:106:24), invariantPostCond=false), Assert(range=CriticalExploits.spec:114:9, exp=to_mathint(balanceBefore) - to_mathint(coveredBefore) >= to_mathint(balanceAfter) - to_mathint(coveredAfter), description="CRITICAL EXPLOIT: Refund extracted more than excess balance", scope=(Spec file -> Rule exploit_refund_steals_covered_debt -> If branch at CriticalExploits.spec:106:5 -> Block at CriticalExploits.spec:106:24), invariantPostCond=false)], scope=(Spec file -> Rule exploit_refund_steals_covered_debt -> If branch at CriticalExploits.spec:106:5 -> Block at CriticalExploits.spec:106:24)), elseCmd=Nop(range=CriticalExploits.spec:106:5, scope=(Spec file -> Rule exploit_refund_steals_covered_debt)), scope=(Spec file -> Rule exploit_refund_steals_covered_debt)), Assert(range=CriticalExploits.spec:116:5, exp=true, description=null, scope=(Spec file -> Rule exploit_refund_steals_covered_debt), invariantPostCond=false)], ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, scope=(Spec file -> Rule exploit_refund_steals_covered_debt), methodParamFilters=MethodParamFilters(range=CriticalExploits.spec:87:1, scope=(Spec file -> Rule exploit_refund_steals_covered_debt), methodParamToFilter={}), ruleGenerationMeta=WithSanity(sanity=PRE_SANITY_CHECK), isSatisfyRule=false)), parentCVLDeclarationId=exploit_refund_steals_covered_debt, isCounted=true): true,
	RegisteredRule(rule=Assert_CRITICAL_EXPLOIT__Withdrew_more_than_balance__overflow_detected_(CriticalExploits_spec_75_9), ruleType=AssertSpecFile(originalRule=CVLSingleRule(ruleIdentifier=exploit_debt_overflow_manipulation, range=CriticalExploits.spec:45:1, params=[uint256 streamId], description=, goodDescription=, block=[Declaration(range=CriticalExploits.spec:46:5, cvlType=env, id=e, scope=(Spec file -> Rule exploit_debt_overflow_manipulation)), Assume(range=CriticalExploits.spec:48:5, exp=!(SablierFlow.isVoided(streamId)), description=null, scope=(Spec file -> Rule exploit_debt_overflow_manipulation), invariantPreCond=false, comesFromSpec=true), uint40 snapshotTime = SablierFlow.getSnapshotTime(streamId), uint256 snapshotDebtScaled = SablierFlow.getSnapshotDebtScaled(streamId), Assume(range=CriticalExploits.spec:52:5, exp=e.block.timestamp > snapshotTime, description=null, scope=(Spec file -> Rule exploit_debt_overflow_manipulation), invariantPreCond=false, comesFromSpec=true), uint256 timeDelta = require_uint256(e.block.timestamp - snapshotTime), uint256 scaledRate = SablierFlow.ongoingDebtScaledOf(e,streamId), uint256 maxDebt = max_uint256, Assume(range=CriticalExploits.spec:60:5, exp=scaledRate > 0, description=null, scope=(Spec file -> Rule exploit_debt_overflow_manipulation), invariantPreCond=false, comesFromSpec=true), Assume(range=CriticalExploits.spec:61:5, exp=timeDelta > 0, description=null, scope=(Spec file -> Rule exploit_debt_overflow_manipulation), invariantPreCond=false, comesFromSpec=true), uint256 totalDebtBefore = SablierFlow.totalDebtOf(e,streamId), uint128 coveredBefore = SablierFlow.coveredDebtOf(e,streamId), uint128 balanceBefore = SablierFlow.getBalance(streamId), uint128 withdrawAmount = coveredBefore, Apply(range=CriticalExploits.spec:69:5, exp=SablierFlow.withdraw(e,streamId,SablierFlow.getSender(streamId),withdrawAmount) could_revert, scope=(Spec file -> Rule exploit_debt_overflow_manipulation)), If(range=CriticalExploits.spec:71:5, cond=!(lastReverted), thenCmd=Block(range=CriticalExploits.spec:71:24, block=[uint128 balanceAfter = SablierFlow.getBalance(streamId), Assert(range=CriticalExploits.spec:75:9, exp=to_mathint(balanceBefore) >= to_mathint(withdrawAmount), description="CRITICAL EXPLOIT: Withdrew more than balance - overflow detected", scope=(Spec file -> Rule exploit_debt_overflow_manipulation -> If branch at CriticalExploits.spec:71:5 -> Block at CriticalExploits.spec:71:24), invariantPostCond=false), Assert(range=CriticalExploits.spec:77:9, exp=to_mathint(balanceAfter) == to_mathint(balanceBefore) - to_mathint(withdrawAmount), description="CRITICAL EXPLOIT: Balance accounting broken - overflow detected", scope=(Spec file -> Rule exploit_debt_overflow_manipulation -> If branch at CriticalExploits.spec:71:5 -> Block at CriticalExploits.spec:71:24), invariantPostCond=false)], scope=(Spec file -> Rule exploit_debt_overflow_manipulation -> If branch at CriticalExploits.spec:71:5 -> Block at CriticalExploits.spec:71:24)), elseCmd=Nop(range=CriticalExploits.spec:71:5, scope=(Spec file -> Rule exploit_debt_overflow_manipulation)), scope=(Spec file -> Rule exploit_debt_overflow_manipulation)), Assert(range=CriticalExploits.spec:79:5, exp=true, description=null, scope=(Spec file -> Rule exploit_debt_overflow_manipulation), invariantPostCond=false)], ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, scope=(Spec file -> Rule exploit_debt_overflow_manipulation), methodParamFilters=MethodParamFilters(range=CriticalExploits.spec:45:1, scope=(Spec file -> Rule exploit_debt_overflow_manipulation), methodParamToFilter={}), ruleGenerationMeta=WithSanity(sanity=PRE_SANITY_CHECK), isSatisfyRule=false), assertId=11, assertMessage="CRITICAL EXPLOIT: Withdrew more than balance - overflow detected", cvlCmdLoc=CriticalExploits.spec:75:9), parentCVLDeclarationId=exploit_debt_overflow_manipulation, isCounted=true): true,
	RegisteredRule(rule=Assert_CRITICAL_EXPLOIT__Balance_accounting_broken__overflow_detected_(CriticalExploits_spec_77_9), ruleType=AssertSpecFile(originalRule=CVLSingleRule(ruleIdentifier=exploit_debt_overflow_manipulation, range=CriticalExploits.spec:45:1, params=[uint256 streamId], description=, goodDescription=, block=[Declaration(range=CriticalExploits.spec:46:5, cvlType=env, id=e, scope=(Spec file -> Rule exploit_debt_overflow_manipulation)), Assume(range=CriticalExploits.spec:48:5, exp=!(SablierFlow.isVoided(streamId)), description=null, scope=(Spec file -> Rule exploit_debt_overflow_manipulation), invariantPreCond=false, comesFromSpec=true), uint40 snapshotTime = SablierFlow.getSnapshotTime(streamId), uint256 snapshotDebtScaled = SablierFlow.getSnapshotDebtScaled(streamId), Assume(range=CriticalExploits.spec:52:5, exp=e.block.timestamp > snapshotTime, description=null, scope=(Spec file -> Rule exploit_debt_overflow_manipulation), invariantPreCond=false, comesFromSpec=true), uint256 timeDelta = require_uint256(e.block.timestamp - snapshotTime), uint256 scaledRate = SablierFlow.ongoingDebtScaledOf(e,streamId), uint256 maxDebt = max_uint256, Assume(range=CriticalExploits.spec:60:5, exp=scaledRate > 0, description=null, scope=(Spec file -> Rule exploit_debt_overflow_manipulation), invariantPreCond=false, comesFromSpec=true), Assume(range=CriticalExploits.spec:61:5, exp=timeDelta > 0, description=null, scope=(Spec file -> Rule exploit_debt_overflow_manipulation), invariantPreCond=false, comesFromSpec=true), uint256 totalDebtBefore = SablierFlow.totalDebtOf(e,streamId), uint128 coveredBefore = SablierFlow.coveredDebtOf(e,streamId), uint128 balanceBefore = SablierFlow.getBalance(streamId), uint128 withdrawAmount = coveredBefore, Apply(range=CriticalExploits.spec:69:5, exp=SablierFlow.withdraw(e,streamId,SablierFlow.getSender(streamId),withdrawAmount) could_revert, scope=(Spec file -> Rule exploit_debt_overflow_manipulation)), If(range=CriticalExploits.spec:71:5, cond=!(lastReverted), thenCmd=Block(range=CriticalExploits.spec:71:24, block=[uint128 balanceAfter = SablierFlow.getBalance(streamId), Assert(range=CriticalExploits.spec:75:9, exp=to_mathint(balanceBefore) >= to_mathint(withdrawAmount), description="CRITICAL EXPLOIT: Withdrew more than balance - overflow detected", scope=(Spec file -> Rule exploit_debt_overflow_manipulation -> If branch at CriticalExploits.spec:71:5 -> Block at CriticalExploits.spec:71:24), invariantPostCond=false), Assert(range=CriticalExploits.spec:77:9, exp=to_mathint(balanceAfter) == to_mathint(balanceBefore) - to_mathint(withdrawAmount), description="CRITICAL EXPLOIT: Balance accounting broken - overflow detected", scope=(Spec file -> Rule exploit_debt_overflow_manipulation -> If branch at CriticalExploits.spec:71:5 -> Block at CriticalExploits.spec:71:24), invariantPostCond=false)], scope=(Spec file -> Rule exploit_debt_overflow_manipulation -> If branch at CriticalExploits.spec:71:5 -> Block at CriticalExploits.spec:71:24)), elseCmd=Nop(range=CriticalExploits.spec:71:5, scope=(Spec file -> Rule exploit_debt_overflow_manipulation)), scope=(Spec file -> Rule exploit_debt_overflow_manipulation)), Assert(range=CriticalExploits.spec:79:5, exp=true, description=null, scope=(Spec file -> Rule exploit_debt_overflow_manipulation), invariantPostCond=false)], ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, scope=(Spec file -> Rule exploit_debt_overflow_manipulation), methodParamFilters=MethodParamFilters(range=CriticalExploits.spec:45:1, scope=(Spec file -> Rule exploit_debt_overflow_manipulation), methodParamToFilter={}), ruleGenerationMeta=WithSanity(sanity=PRE_SANITY_CHECK), isSatisfyRule=false), assertId=12, assertMessage="CRITICAL EXPLOIT: Balance accounting broken - overflow detected", cvlCmdLoc=CriticalExploits.spec:77:9), parentCVLDeclarationId=exploit_debt_overflow_manipulation, isCounted=true): true,
	RegisteredRule(rule=Assert_true_(CriticalExploits_spec_79_5), ruleType=AssertSpecFile(originalRule=CVLSingleRule(ruleIdentifier=exploit_debt_overflow_manipulation, range=CriticalExploits.spec:45:1, params=[uint256 streamId], description=, goodDescription=, block=[Declaration(range=CriticalExploits.spec:46:5, cvlType=env, id=e, scope=(Spec file -> Rule exploit_debt_overflow_manipulation)), Assume(range=CriticalExploits.spec:48:5, exp=!(SablierFlow.isVoided(streamId)), description=null, scope=(Spec file -> Rule exploit_debt_overflow_manipulation), invariantPreCond=false, comesFromSpec=true), uint40 snapshotTime = SablierFlow.getSnapshotTime(streamId), uint256 snapshotDebtScaled = SablierFlow.getSnapshotDebtScaled(streamId), Assume(range=CriticalExploits.spec:52:5, exp=e.block.timestamp > snapshotTime, description=null, scope=(Spec file -> Rule exploit_debt_overflow_manipulation), invariantPreCond=false, comesFromSpec=true), uint256 timeDelta = require_uint256(e.block.timestamp - snapshotTime), uint256 scaledRate = SablierFlow.ongoingDebtScaledOf(e,streamId), uint256 maxDebt = max_uint256, Assume(range=CriticalExploits.spec:60:5, exp=scaledRate > 0, description=null, scope=(Spec file -> Rule exploit_debt_overflow_manipulation), invariantPreCond=false, comesFromSpec=true), Assume(range=CriticalExploits.spec:61:5, exp=timeDelta > 0, description=null, scope=(Spec file -> Rule exploit_debt_overflow_manipulation), invariantPreCond=false, comesFromSpec=true), uint256 totalDebtBefore = SablierFlow.totalDebtOf(e,streamId), uint128 coveredBefore = SablierFlow.coveredDebtOf(e,streamId), uint128 balanceBefore = SablierFlow.getBalance(streamId), uint128 withdrawAmount = coveredBefore, Apply(range=CriticalExploits.spec:69:5, exp=SablierFlow.withdraw(e,streamId,SablierFlow.getSender(streamId),withdrawAmount) could_revert, scope=(Spec file -> Rule exploit_debt_overflow_manipulation)), If(range=CriticalExploits.spec:71:5, cond=!(lastReverted), thenCmd=Block(range=CriticalExploits.spec:71:24, block=[uint128 balanceAfter = SablierFlow.getBalance(streamId), Assert(range=CriticalExploits.spec:75:9, exp=to_mathint(balanceBefore) >= to_mathint(withdrawAmount), description="CRITICAL EXPLOIT: Withdrew more than balance - overflow detected", scope=(Spec file -> Rule exploit_debt_overflow_manipulation -> If branch at CriticalExploits.spec:71:5 -> Block at CriticalExploits.spec:71:24), invariantPostCond=false), Assert(range=CriticalExploits.spec:77:9, exp=to_mathint(balanceAfter) == to_mathint(balanceBefore) - to_mathint(withdrawAmount), description="CRITICAL EXPLOIT: Balance accounting broken - overflow detected", scope=(Spec file -> Rule exploit_debt_overflow_manipulation -> If branch at CriticalExploits.spec:71:5 -> Block at CriticalExploits.spec:71:24), invariantPostCond=false)], scope=(Spec file -> Rule exploit_debt_overflow_manipulation -> If branch at CriticalExploits.spec:71:5 -> Block at CriticalExploits.spec:71:24)), elseCmd=Nop(range=CriticalExploits.spec:71:5, scope=(Spec file -> Rule exploit_debt_overflow_manipulation)), scope=(Spec file -> Rule exploit_debt_overflow_manipulation)), Assert(range=CriticalExploits.spec:79:5, exp=true, description=null, scope=(Spec file -> Rule exploit_debt_overflow_manipulation), invariantPostCond=false)], ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, scope=(Spec file -> Rule exploit_debt_overflow_manipulation), methodParamFilters=MethodParamFilters(range=CriticalExploits.spec:45:1, scope=(Spec file -> Rule exploit_debt_overflow_manipulation), methodParamToFilter={}), ruleGenerationMeta=WithSanity(sanity=PRE_SANITY_CHECK), isSatisfyRule=false), assertId=13, assertMessage=true, cvlCmdLoc=CriticalExploits.spec:79:5), parentCVLDeclarationId=exploit_debt_overflow_manipulation, isCounted=true): true,
	RegisteredRule(rule=CheckAutoGeneratedAsserts, ruleType=AutoGenerated(originalRule=CVLSingleRule(ruleIdentifier=exploit_debt_overflow_manipulation, range=CriticalExploits.spec:45:1, params=[uint256 streamId], description=, goodDescription=, block=[Declaration(range=CriticalExploits.spec:46:5, cvlType=env, id=e, scope=(Spec file -> Rule exploit_debt_overflow_manipulation)), Assume(range=CriticalExploits.spec:48:5, exp=!(SablierFlow.isVoided(streamId)), description=null, scope=(Spec file -> Rule exploit_debt_overflow_manipulation), invariantPreCond=false, comesFromSpec=true), uint40 snapshotTime = SablierFlow.getSnapshotTime(streamId), uint256 snapshotDebtScaled = SablierFlow.getSnapshotDebtScaled(streamId), Assume(range=CriticalExploits.spec:52:5, exp=e.block.timestamp > snapshotTime, description=null, scope=(Spec file -> Rule exploit_debt_overflow_manipulation), invariantPreCond=false, comesFromSpec=true), uint256 timeDelta = require_uint256(e.block.timestamp - snapshotTime), uint256 scaledRate = SablierFlow.ongoingDebtScaledOf(e,streamId), uint256 maxDebt = max_uint256, Assume(range=CriticalExploits.spec:60:5, exp=scaledRate > 0, description=null, scope=(Spec file -> Rule exploit_debt_overflow_manipulation), invariantPreCond=false, comesFromSpec=true), Assume(range=CriticalExploits.spec:61:5, exp=timeDelta > 0, description=null, scope=(Spec file -> Rule exploit_debt_overflow_manipulation), invariantPreCond=false, comesFromSpec=true), uint256 totalDebtBefore = SablierFlow.totalDebtOf(e,streamId), uint128 coveredBefore = SablierFlow.coveredDebtOf(e,streamId), uint128 balanceBefore = SablierFlow.getBalance(streamId), uint128 withdrawAmount = coveredBefore, Apply(range=CriticalExploits.spec:69:5, exp=SablierFlow.withdraw(e,streamId,SablierFlow.getSender(streamId),withdrawAmount) could_revert, scope=(Spec file -> Rule exploit_debt_overflow_manipulation)), If(range=CriticalExploits.spec:71:5, cond=!(lastReverted), thenCmd=Block(range=CriticalExploits.spec:71:24, block=[uint128 balanceAfter = SablierFlow.getBalance(streamId), Assert(range=CriticalExploits.spec:75:9, exp=to_mathint(balanceBefore) >= to_mathint(withdrawAmount), description="CRITICAL EXPLOIT: Withdrew more than balance - overflow detected", scope=(Spec file -> Rule exploit_debt_overflow_manipulation -> If branch at CriticalExploits.spec:71:5 -> Block at CriticalExploits.spec:71:24), invariantPostCond=false), Assert(range=CriticalExploits.spec:77:9, exp=to_mathint(balanceAfter) == to_mathint(balanceBefore) - to_mathint(withdrawAmount), description="CRITICAL EXPLOIT: Balance accounting broken - overflow detected", scope=(Spec file -> Rule exploit_debt_overflow_manipulation -> If branch at CriticalExploits.spec:71:5 -> Block at CriticalExploits.spec:71:24), invariantPostCond=false)], scope=(Spec file -> Rule exploit_debt_overflow_manipulation -> If branch at CriticalExploits.spec:71:5 -> Block at CriticalExploits.spec:71:24)), elseCmd=Nop(range=CriticalExploits.spec:71:5, scope=(Spec file -> Rule exploit_debt_overflow_manipulation)), scope=(Spec file -> Rule exploit_debt_overflow_manipulation)), Assert(range=CriticalExploits.spec:79:5, exp=true, description=null, scope=(Spec file -> Rule exploit_debt_overflow_manipulation), invariantPostCond=false)], ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, scope=(Spec file -> Rule exploit_debt_overflow_manipulation), methodParamFilters=MethodParamFilters(range=CriticalExploits.spec:45:1, scope=(Spec file -> Rule exploit_debt_overflow_manipulation), methodParamToFilter={}), ruleGenerationMeta=WithSanity(sanity=PRE_SANITY_CHECK), isSatisfyRule=false)), parentCVLDeclarationId=exploit_debt_overflow_manipulation, isCounted=true): true,
	RegisteredRule(rule=Assert_CRITICAL_EXPLOIT__Deposit_did_not_increase_balance__frontrun_attack_(CriticalExploits_spec_201_5), ruleType=AssertSpecFile(originalRule=CVLSingleRule(ruleIdentifier=exploit_deposit_front_running, range=CriticalExploits.spec:171:1, params=[uint256 streamId, uint128 depositAmount], description=, goodDescription=, block=[Declaration(range=CriticalExploits.spec:172:5, cvlType=env, id=e1, scope=(Spec file -> Rule exploit_deposit_front_running)), Declaration(range=CriticalExploits.spec:173:5, cvlType=env, id=e2, scope=(Spec file -> Rule exploit_deposit_front_running)), Assume(range=CriticalExploits.spec:175:5, exp=e1.block.timestamp == e2.block.timestamp, description=null, scope=(Spec file -> Rule exploit_deposit_front_running), invariantPreCond=false, comesFromSpec=true), Assume(range=CriticalExploits.spec:176:5, exp=e1.msg.sender != e2.msg.sender, description=null, scope=(Spec file -> Rule exploit_deposit_front_running), invariantPreCond=false, comesFromSpec=true), Assume(range=CriticalExploits.spec:177:5, exp=depositAmount > 0, description=null, scope=(Spec file -> Rule exploit_deposit_front_running), invariantPreCond=false, comesFromSpec=true), Assume(range=CriticalExploits.spec:178:5, exp=!(SablierFlow.isVoided(streamId)), description=null, scope=(Spec file -> Rule exploit_deposit_front_running), invariantPreCond=false, comesFromSpec=true), address attacker = e1.msg.sender, address victim = e2.msg.sender, address sender = SablierFlow.getSender(streamId), address recipient = SablierFlow.getRecipient(streamId), uint128 balanceBefore = SablierFlow.getBalance(streamId), uint256 totalDebtBefore = SablierFlow.totalDebtOf(e1,streamId), uint128 coveredBeforeAttack = SablierFlow.coveredDebtOf(e1,streamId), If(range=CriticalExploits.spec:190:5, cond=coveredBeforeAttack > 0, thenCmd=Block(range=CriticalExploits.spec:190:34, block=[Apply(range=CriticalExploits.spec:191:9, exp=SablierFlow.withdraw(e1,streamId,recipient,coveredBeforeAttack), scope=(Spec file -> Rule exploit_deposit_front_running -> If branch at CriticalExploits.spec:190:5 -> Block at CriticalExploits.spec:190:34))], scope=(Spec file -> Rule exploit_deposit_front_running -> If branch at CriticalExploits.spec:190:5 -> Block at CriticalExploits.spec:190:34)), elseCmd=Nop(range=CriticalExploits.spec:190:5, scope=(Spec file -> Rule exploit_deposit_front_running)), scope=(Spec file -> Rule exploit_deposit_front_running)), Apply(range=CriticalExploits.spec:195:5, exp=SablierFlow.deposit(e2,streamId,depositAmount,sender,recipient), scope=(Spec file -> Rule exploit_deposit_front_running)), uint128 balanceAfter = SablierFlow.getBalance(streamId), uint128 coveredAfter = SablierFlow.coveredDebtOf(e2,streamId), Assert(range=CriticalExploits.spec:201:5, exp=to_mathint(balanceAfter) >= to_mathint(depositAmount), description="CRITICAL EXPLOIT: Deposit did not increase balance - front-run attack", scope=(Spec file -> Rule exploit_deposit_front_running), invariantPostCond=false)], ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, scope=(Spec file -> Rule exploit_deposit_front_running), methodParamFilters=MethodParamFilters(range=CriticalExploits.spec:171:1, scope=(Spec file -> Rule exploit_deposit_front_running), methodParamToFilter={}), ruleGenerationMeta=WithSanity(sanity=PRE_SANITY_CHECK), isSatisfyRule=false), assertId=14, assertMessage="CRITICAL EXPLOIT: Deposit did not increase balance - front-run attack", cvlCmdLoc=CriticalExploits.spec:201:5), parentCVLDeclarationId=exploit_deposit_front_running, isCounted=true): true,
	RegisteredRule(rule=CheckAutoGeneratedAsserts, ruleType=AutoGenerated(originalRule=CVLSingleRule(ruleIdentifier=exploit_deposit_front_running, range=CriticalExploits.spec:171:1, params=[uint256 streamId, uint128 depositAmount], description=, goodDescription=, block=[Declaration(range=CriticalExploits.spec:172:5, cvlType=env, id=e1, scope=(Spec file -> Rule exploit_deposit_front_running)), Declaration(range=CriticalExploits.spec:173:5, cvlType=env, id=e2, scope=(Spec file -> Rule exploit_deposit_front_running)), Assume(range=CriticalExploits.spec:175:5, exp=e1.block.timestamp == e2.block.timestamp, description=null, scope=(Spec file -> Rule exploit_deposit_front_running), invariantPreCond=false, comesFromSpec=true), Assume(range=CriticalExploits.spec:176:5, exp=e1.msg.sender != e2.msg.sender, description=null, scope=(Spec file -> Rule exploit_deposit_front_running), invariantPreCond=false, comesFromSpec=true), Assume(range=CriticalExploits.spec:177:5, exp=depositAmount > 0, description=null, scope=(Spec file -> Rule exploit_deposit_front_running), invariantPreCond=false, comesFromSpec=true), Assume(range=CriticalExploits.spec:178:5, exp=!(SablierFlow.isVoided(streamId)), description=null, scope=(Spec file -> Rule exploit_deposit_front_running), invariantPreCond=false, comesFromSpec=true), address attacker = e1.msg.sender, address victim = e2.msg.sender, address sender = SablierFlow.getSender(streamId), address recipient = SablierFlow.getRecipient(streamId), uint128 balanceBefore = SablierFlow.getBalance(streamId), uint256 totalDebtBefore = SablierFlow.totalDebtOf(e1,streamId), uint128 coveredBeforeAttack = SablierFlow.coveredDebtOf(e1,streamId), If(range=CriticalExploits.spec:190:5, cond=coveredBeforeAttack > 0, thenCmd=Block(range=CriticalExploits.spec:190:34, block=[Apply(range=CriticalExploits.spec:191:9, exp=SablierFlow.withdraw(e1,streamId,recipient,coveredBeforeAttack), scope=(Spec file -> Rule exploit_deposit_front_running -> If branch at CriticalExploits.spec:190:5 -> Block at CriticalExploits.spec:190:34))], scope=(Spec file -> Rule exploit_deposit_front_running -> If branch at CriticalExploits.spec:190:5 -> Block at CriticalExploits.spec:190:34)), elseCmd=Nop(range=CriticalExploits.spec:190:5, scope=(Spec file -> Rule exploit_deposit_front_running)), scope=(Spec file -> Rule exploit_deposit_front_running)), Apply(range=CriticalExploits.spec:195:5, exp=SablierFlow.deposit(e2,streamId,depositAmount,sender,recipient), scope=(Spec file -> Rule exploit_deposit_front_running)), uint128 balanceAfter = SablierFlow.getBalance(streamId), uint128 coveredAfter = SablierFlow.coveredDebtOf(e2,streamId), Assert(range=CriticalExploits.spec:201:5, exp=to_mathint(balanceAfter) >= to_mathint(depositAmount), description="CRITICAL EXPLOIT: Deposit did not increase balance - front-run attack", scope=(Spec file -> Rule exploit_deposit_front_running), invariantPostCond=false)], ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, scope=(Spec file -> Rule exploit_deposit_front_running), methodParamFilters=MethodParamFilters(range=CriticalExploits.spec:171:1, scope=(Spec file -> Rule exploit_deposit_front_running), methodParamToFilter={}), ruleGenerationMeta=WithSanity(sanity=PRE_SANITY_CHECK), isSatisfyRule=false)), parentCVLDeclarationId=exploit_deposit_front_running, isCounted=true): true,
	RegisteredRule(rule=rule_not_vacuous, ruleType=VacuityCheck(originalRule=CVLSingleRule(ruleIdentifier=exploit_uncovered_debt_calculation, range=CriticalExploits.spec:146:1, params=[uint256 streamId], description=, goodDescription=, block=[Declaration(range=CriticalExploits.spec:147:5, cvlType=env, id=e, scope=(Spec file -> Rule exploit_uncovered_debt_calculation)), Assume(range=CriticalExploits.spec:149:5, exp=!(SablierFlow.isVoided(streamId)), description=null, scope=(Spec file -> Rule exploit_uncovered_debt_calculation), invariantPreCond=false, comesFromSpec=true), uint256 totalDebt = SablierFlow.totalDebtOf(e,streamId), uint128 covered = SablierFlow.coveredDebtOf(e,streamId), uint256 uncovered = SablierFlow.uncoveredDebtOf(e,streamId), uint128 balance = SablierFlow.getBalance(streamId), Assert(range=CriticalExploits.spec:157:5, exp=to_mathint(totalDebt) == to_mathint(covered) + to_mathint(uncovered), description="CRITICAL EXPLOIT: Debt accounting mismatch - manipulation possible", scope=(Spec file -> Rule exploit_uncovered_debt_calculation), invariantPostCond=false), Assert(range=CriticalExploits.spec:160:5, exp=covered <= balance, description="CRITICAL EXPLOIT: Covered debt exceeds balance - insolvency", scope=(Spec file -> Rule exploit_uncovered_debt_calculation), invariantPostCond=false), Assert(range=CriticalExploits.spec:163:5, exp=(uncovered > 0) => (balance < totalDebt), description="CRITICAL EXPLOIT: Uncovered debt exists but balance covers total debt", scope=(Spec file -> Rule exploit_uncovered_debt_calculation), invariantPostCond=false)], ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, scope=(Spec file -> Rule exploit_uncovered_debt_calculation), methodParamFilters=MethodParamFilters(range=CriticalExploits.spec:146:1, scope=(Spec file -> Rule exploit_uncovered_debt_calculation), methodParamToFilter={}), ruleGenerationMeta=WithSanity(sanity=PRE_SANITY_CHECK), isSatisfyRule=false)), parentCVLDeclarationId=exploit_uncovered_debt_calculation, isCounted=true): true,
	RegisteredRule(rule=rule_not_vacuous, ruleType=VacuityCheck(originalRule=CVLSingleRule(ruleIdentifier=exploit_time_based_debt_manipulation, range=CriticalExploits.spec:209:1, params=[uint256 streamId], description=, goodDescription=, block=[Declaration(range=CriticalExploits.spec:210:5, cvlType=env, id=e1, scope=(Spec file -> Rule exploit_time_based_debt_manipulation)), Declaration(range=CriticalExploits.spec:211:5, cvlType=env, id=e2, scope=(Spec file -> Rule exploit_time_based_debt_manipulation)), Assume(range=CriticalExploits.spec:213:5, exp=!(SablierFlow.isVoided(streamId)), description=null, scope=(Spec file -> Rule exploit_time_based_debt_manipulation), invariantPreCond=false, comesFromSpec=true), Assume(range=CriticalExploits.spec:214:5, exp=e2.block.timestamp > e1.block.timestamp, description=null, scope=(Spec file -> Rule exploit_time_based_debt_manipulation), invariantPreCond=false, comesFromSpec=true), Assume(range=CriticalExploits.spec:217:5, exp=to_mathint(e2.block.timestamp) - to_mathint(e1.block.timestamp) > 365 * 24 * 3600, description=null, scope=(Spec file -> Rule exploit_time_based_debt_manipulation), invariantPreCond=false, comesFromSpec=true), uint256 debt1 = SablierFlow.totalDebtOf(e1,streamId), uint256 debt2 = SablierFlow.totalDebtOf(e2,streamId), Assert(range=CriticalExploits.spec:223:5, exp=to_mathint(debt2) >= to_mathint(debt1), description="CRITICAL EXPLOIT: Debt decreased over time - overflow detected", scope=(Spec file -> Rule exploit_time_based_debt_manipulation), invariantPostCond=false)], ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, scope=(Spec file -> Rule exploit_time_based_debt_manipulation), methodParamFilters=MethodParamFilters(range=CriticalExploits.spec:209:1, scope=(Spec file -> Rule exploit_time_based_debt_manipulation), methodParamToFilter={}), ruleGenerationMeta=WithSanity(sanity=PRE_SANITY_CHECK), isSatisfyRule=false)), parentCVLDeclarationId=exploit_time_based_debt_manipulation, isCounted=true): true,
	RegisteredRule(rule=rule_not_vacuous, ruleType=VacuityCheck(originalRule=CVLSingleRule(ruleIdentifier=exploit_refund_steals_covered_debt, range=CriticalExploits.spec:87:1, params=[uint256 streamId], description=, goodDescription=, block=[Declaration(range=CriticalExploits.spec:88:5, cvlType=env, id=e, scope=(Spec file -> Rule exploit_refund_steals_covered_debt)), Assume(range=CriticalExploits.spec:90:5, exp=!(SablierFlow.isVoided(streamId)), description=null, scope=(Spec file -> Rule exploit_refund_steals_covered_debt), invariantPreCond=false, comesFromSpec=true), uint128 coveredBefore = SablierFlow.coveredDebtOf(e,streamId), uint128 balanceBefore = SablierFlow.getBalance(streamId), uint128 refundableBefore = SablierFlow.refundableAmountOf(e,streamId), Assume(range=CriticalExploits.spec:96:5, exp=coveredBefore > 0, description=null, scope=(Spec file -> Rule exploit_refund_steals_covered_debt), invariantPreCond=false, comesFromSpec=true), Assume(range=CriticalExploits.spec:97:5, exp=balanceBefore > coveredBefore, description=null, scope=(Spec file -> Rule exploit_refund_steals_covered_debt), invariantPreCond=false, comesFromSpec=true), uint128 refundAmount = refundableBefore, Assume(range=CriticalExploits.spec:102:5, exp=refundAmount > 0, description=null, scope=(Spec file -> Rule exploit_refund_steals_covered_debt), invariantPreCond=false, comesFromSpec=true), Apply(range=CriticalExploits.spec:104:5, exp=SablierFlow.refund(e,streamId,refundAmount) could_revert, scope=(Spec file -> Rule exploit_refund_steals_covered_debt)), If(range=CriticalExploits.spec:106:5, cond=!(lastReverted), thenCmd=Block(range=CriticalExploits.spec:106:24, block=[uint128 coveredAfter = SablierFlow.coveredDebtOf(e,streamId), uint128 balanceAfter = SablierFlow.getBalance(streamId), Assert(range=CriticalExploits.spec:111:9, exp=coveredAfter >= coveredBefore || balanceAfter < coveredBefore, description="CRITICAL EXPLOIT: Refund stole covered debt from recipient", scope=(Spec file -> Rule exploit_refund_steals_covered_debt -> If branch at CriticalExploits.spec:106:5 -> Block at CriticalExploits.spec:106:24), invariantPostCond=false), Assert(range=CriticalExploits.spec:114:9, exp=to_mathint(balanceBefore) - to_mathint(coveredBefore) >= to_mathint(balanceAfter) - to_mathint(coveredAfter), description="CRITICAL EXPLOIT: Refund extracted more than excess balance", scope=(Spec file -> Rule exploit_refund_steals_covered_debt -> If branch at CriticalExploits.spec:106:5 -> Block at CriticalExploits.spec:106:24), invariantPostCond=false)], scope=(Spec file -> Rule exploit_refund_steals_covered_debt -> If branch at CriticalExploits.spec:106:5 -> Block at CriticalExploits.spec:106:24)), elseCmd=Nop(range=CriticalExploits.spec:106:5, scope=(Spec file -> Rule exploit_refund_steals_covered_debt)), scope=(Spec file -> Rule exploit_refund_steals_covered_debt)), Assert(range=CriticalExploits.spec:116:5, exp=true, description=null, scope=(Spec file -> Rule exploit_refund_steals_covered_debt), invariantPostCond=false)], ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, scope=(Spec file -> Rule exploit_refund_steals_covered_debt), methodParamFilters=MethodParamFilters(range=CriticalExploits.spec:87:1, scope=(Spec file -> Rule exploit_refund_steals_covered_debt), methodParamToFilter={}), ruleGenerationMeta=WithSanity(sanity=PRE_SANITY_CHECK), isSatisfyRule=false)), parentCVLDeclarationId=exploit_refund_steals_covered_debt, isCounted=true): true,
	RegisteredRule(rule=rule_not_vacuous, ruleType=VacuityCheck(originalRule=CVLSingleRule(ruleIdentifier=exploit_debt_overflow_manipulation, range=CriticalExploits.spec:45:1, params=[uint256 streamId], description=, goodDescription=, block=[Declaration(range=CriticalExploits.spec:46:5, cvlType=env, id=e, scope=(Spec file -> Rule exploit_debt_overflow_manipulation)), Assume(range=CriticalExploits.spec:48:5, exp=!(SablierFlow.isVoided(streamId)), description=null, scope=(Spec file -> Rule exploit_debt_overflow_manipulation), invariantPreCond=false, comesFromSpec=true), uint40 snapshotTime = SablierFlow.getSnapshotTime(streamId), uint256 snapshotDebtScaled = SablierFlow.getSnapshotDebtScaled(streamId), Assume(range=CriticalExploits.spec:52:5, exp=e.block.timestamp > snapshotTime, description=null, scope=(Spec file -> Rule exploit_debt_overflow_manipulation), invariantPreCond=false, comesFromSpec=true), uint256 timeDelta = require_uint256(e.block.timestamp - snapshotTime), uint256 scaledRate = SablierFlow.ongoingDebtScaledOf(e,streamId), uint256 maxDebt = max_uint256, Assume(range=CriticalExploits.spec:60:5, exp=scaledRate > 0, description=null, scope=(Spec file -> Rule exploit_debt_overflow_manipulation), invariantPreCond=false, comesFromSpec=true), Assume(range=CriticalExploits.spec:61:5, exp=timeDelta > 0, description=null, scope=(Spec file -> Rule exploit_debt_overflow_manipulation), invariantPreCond=false, comesFromSpec=true), uint256 totalDebtBefore = SablierFlow.totalDebtOf(e,streamId), uint128 coveredBefore = SablierFlow.coveredDebtOf(e,streamId), uint128 balanceBefore = SablierFlow.getBalance(streamId), uint128 withdrawAmount = coveredBefore, Apply(range=CriticalExploits.spec:69:5, exp=SablierFlow.withdraw(e,streamId,SablierFlow.getSender(streamId),withdrawAmount) could_revert, scope=(Spec file -> Rule exploit_debt_overflow_manipulation)), If(range=CriticalExploits.spec:71:5, cond=!(lastReverted), thenCmd=Block(range=CriticalExploits.spec:71:24, block=[uint128 balanceAfter = SablierFlow.getBalance(streamId), Assert(range=CriticalExploits.spec:75:9, exp=to_mathint(balanceBefore) >= to_mathint(withdrawAmount), description="CRITICAL EXPLOIT: Withdrew more than balance - overflow detected", scope=(Spec file -> Rule exploit_debt_overflow_manipulation -> If branch at CriticalExploits.spec:71:5 -> Block at CriticalExploits.spec:71:24), invariantPostCond=false), Assert(range=CriticalExploits.spec:77:9, exp=to_mathint(balanceAfter) == to_mathint(balanceBefore) - to_mathint(withdrawAmount), description="CRITICAL EXPLOIT: Balance accounting broken - overflow detected", scope=(Spec file -> Rule exploit_debt_overflow_manipulation -> If branch at CriticalExploits.spec:71:5 -> Block at CriticalExploits.spec:71:24), invariantPostCond=false)], scope=(Spec file -> Rule exploit_debt_overflow_manipulation -> If branch at CriticalExploits.spec:71:5 -> Block at CriticalExploits.spec:71:24)), elseCmd=Nop(range=CriticalExploits.spec:71:5, scope=(Spec file -> Rule exploit_debt_overflow_manipulation)), scope=(Spec file -> Rule exploit_debt_overflow_manipulation)), Assert(range=CriticalExploits.spec:79:5, exp=true, description=null, scope=(Spec file -> Rule exploit_debt_overflow_manipulation), invariantPostCond=false)], ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, scope=(Spec file -> Rule exploit_debt_overflow_manipulation), methodParamFilters=MethodParamFilters(range=CriticalExploits.spec:45:1, scope=(Spec file -> Rule exploit_debt_overflow_manipulation), methodParamToFilter={}), ruleGenerationMeta=WithSanity(sanity=PRE_SANITY_CHECK), isSatisfyRule=false)), parentCVLDeclarationId=exploit_debt_overflow_manipulation, isCounted=true): true,
	RegisteredRule(rule=rule_not_vacuous, ruleType=VacuityCheck(originalRule=CVLSingleRule(ruleIdentifier=exploit_deposit_front_running, range=CriticalExploits.spec:171:1, params=[uint256 streamId, uint128 depositAmount], description=, goodDescription=, block=[Declaration(range=CriticalExploits.spec:172:5, cvlType=env, id=e1, scope=(Spec file -> Rule exploit_deposit_front_running)), Declaration(range=CriticalExploits.spec:173:5, cvlType=env, id=e2, scope=(Spec file -> Rule exploit_deposit_front_running)), Assume(range=CriticalExploits.spec:175:5, exp=e1.block.timestamp == e2.block.timestamp, description=null, scope=(Spec file -> Rule exploit_deposit_front_running), invariantPreCond=false, comesFromSpec=true), Assume(range=CriticalExploits.spec:176:5, exp=e1.msg.sender != e2.msg.sender, description=null, scope=(Spec file -> Rule exploit_deposit_front_running), invariantPreCond=false, comesFromSpec=true), Assume(range=CriticalExploits.spec:177:5, exp=depositAmount > 0, description=null, scope=(Spec file -> Rule exploit_deposit_front_running), invariantPreCond=false, comesFromSpec=true), Assume(range=CriticalExploits.spec:178:5, exp=!(SablierFlow.isVoided(streamId)), description=null, scope=(Spec file -> Rule exploit_deposit_front_running), invariantPreCond=false, comesFromSpec=true), address attacker = e1.msg.sender, address victim = e2.msg.sender, address sender = SablierFlow.getSender(streamId), address recipient = SablierFlow.getRecipient(streamId), uint128 balanceBefore = SablierFlow.getBalance(streamId), uint256 totalDebtBefore = SablierFlow.totalDebtOf(e1,streamId), uint128 coveredBeforeAttack = SablierFlow.coveredDebtOf(e1,streamId), If(range=CriticalExploits.spec:190:5, cond=coveredBeforeAttack > 0, thenCmd=Block(range=CriticalExploits.spec:190:34, block=[Apply(range=CriticalExploits.spec:191:9, exp=SablierFlow.withdraw(e1,streamId,recipient,coveredBeforeAttack), scope=(Spec file -> Rule exploit_deposit_front_running -> If branch at CriticalExploits.spec:190:5 -> Block at CriticalExploits.spec:190:34))], scope=(Spec file -> Rule exploit_deposit_front_running -> If branch at CriticalExploits.spec:190:5 -> Block at CriticalExploits.spec:190:34)), elseCmd=Nop(range=CriticalExploits.spec:190:5, scope=(Spec file -> Rule exploit_deposit_front_running)), scope=(Spec file -> Rule exploit_deposit_front_running)), Apply(range=CriticalExploits.spec:195:5, exp=SablierFlow.deposit(e2,streamId,depositAmount,sender,recipient), scope=(Spec file -> Rule exploit_deposit_front_running)), uint128 balanceAfter = SablierFlow.getBalance(streamId), uint128 coveredAfter = SablierFlow.coveredDebtOf(e2,streamId), Assert(range=CriticalExploits.spec:201:5, exp=to_mathint(balanceAfter) >= to_mathint(depositAmount), description="CRITICAL EXPLOIT: Deposit did not increase balance - front-run attack", scope=(Spec file -> Rule exploit_deposit_front_running), invariantPostCond=false)], ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, scope=(Spec file -> Rule exploit_deposit_front_running), methodParamFilters=MethodParamFilters(range=CriticalExploits.spec:171:1, scope=(Spec file -> Rule exploit_deposit_front_running), methodParamToFilter={}), ruleGenerationMeta=WithSanity(sanity=PRE_SANITY_CHECK), isSatisfyRule=false)), parentCVLDeclarationId=exploit_deposit_front_running, isCounted=true): true
}