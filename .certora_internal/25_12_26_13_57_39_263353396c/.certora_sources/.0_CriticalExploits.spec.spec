using SablierFlow as flow;

methods {
    // Core state queries
    function balanceOf(uint256) external returns (uint128) envfree;
    function totalDebtOf(uint256) external returns (uint256) envfree;
    function coveredDebtOf(uint256) external returns (uint128) envfree;
    function uncoveredDebtOf(uint256) external returns (uint256) envfree;
    function refundableAmountOf(uint256) external returns (uint128) envfree;
    function ongoingDebtScaledOf(uint256) external returns (uint256) envfree;
    function depletionTimeOf(uint256) external returns (uint256) envfree;
    
    // Stream properties
    function getRatePerSecond(uint256) external returns (uint256) envfree;
    function getSnapshotTime(uint256) external returns (uint40) envfree;
    function getSnapshotDebtScaled(uint256) external returns (uint256) envfree;
    function isPaused(uint256) external returns (bool) envfree;
    function isVoided(uint256) external returns (bool) envfree;
    function getToken(uint256) external returns (address) envfree;
    function getSender(uint256) external returns (address) envfree;
    function getRecipient(uint256) external returns (address) envfree;
    
    // State-changing functions
    function deposit(uint256, uint128, address, address) external;
    function depositAndPause(uint256, uint128) external;
    function depositViaBroker(uint256, uint128, address, address) external;
    function withdraw(uint256, address, uint128) external;
    function withdrawMax(uint256, address) external returns (uint128);
    function refund(uint256, uint128) external;
    function refundMax(uint256) external;
    function refundAndPause(uint256, uint128) external;
    function pause(uint256) external;
    function restart(uint256, uint256) external;
    function restartAndDeposit(uint256, uint256, uint128) external;
    function void(uint256) external;
    function adjustRatePerSecond(uint256, uint256) external;
    
    // ERC20
    function _.balanceOf(address) external => DISPATCHER(true);
    function _.transfer(address, uint256) external => DISPATCHER(true);
    function _.transferFrom(address, address, uint256) external => DISPATCHER(true);
}

// GHOST for tracking token balances
ghost mapping(address => mapping(address => uint256)) ghostTokenBalances;

// ============================================================================
// CRITICAL EXPLOIT #1: Integer Overflow in Debt Calculation
// ============================================================================
// If ongoingDebtScaledOf * (time - snapshotTime) * SCALE_FACTOR overflows,
// attacker can manipulate debt calculation to steal funds

rule exploit_debt_overflow_manipulation(uint256 streamId) {
    env e;
    
    require !isVoided(streamId);
    require !isPaused(streamId);
    
    uint256 ratePerSec = getRatePerSecond(streamId);
    uint40 snapshotTime = getSnapshotTime(streamId);
    uint256 snapshotDebtScaled = getSnapshotDebtScaled(streamId);
    
    require e.block.timestamp > snapshotTime;
    uint256 timeDelta = require_uint256(e.block.timestamp - snapshotTime);
    
    // Check if multiplication could overflow
    uint256 scaledRate = ongoingDebtScaledOf(streamId);
    
    // If this overflows, totalDebt calculation is wrong
    uint256 maxDebt = max_uint256;
    require scaledRate > 0;
    require timeDelta > 0;
    
    uint256 totalDebtBefore = totalDebtOf(streamId);
    uint128 coveredBefore = coveredDebtOf(streamId);
    uint128 balanceBefore = balanceOf(streamId);
    
    // Try to withdraw max when debt calculation might be corrupted
    uint128 withdrawAmount = coveredBefore;
    withdraw@withrevert(e, streamId, getSender(streamId), withdrawAmount);
    
    if (!lastReverted) {
        uint128 balanceAfter = balanceOf(streamId);
        
        // CRITICAL: If we can withdraw more than we should, it's an exploit
        assert to_mathint(balanceBefore) >= to_mathint(withdrawAmount),
            "CRITICAL EXPLOIT: Withdrew more than balance - overflow detected";
            
        assert to_mathint(balanceAfter) == to_mathint(balanceBefore) - to_mathint(withdrawAmount),
            "CRITICAL EXPLOIT: Balance accounting broken - overflow detected";
    }
}

// ============================================================================
// CRITICAL EXPLOIT #2: Refund Can Steal Covered Debt
// ============================================================================
// Check if refund allows sender to extract funds that should go to recipient

rule exploit_refund_steals_covered_debt(uint256 streamId) {
    env e;
    
    require !isVoided(streamId);
    
    uint128 coveredBefore = coveredDebtOf(streamId);
    uint128 balanceBefore = balanceOf(streamId);
    uint128 refundableBefore = refundableAmountOf(streamId);
    
    require coveredBefore > 0;
    require balanceBefore > coveredBefore; // There's excess to refund
    
    // Try to refund maximum
    uint128 refundAmount = refundableBefore;
    require refundAmount > 0;
    
    refund@withrevert(e, streamId, refundAmount);
    
    if (!lastReverted) {
        uint128 coveredAfter = coveredDebtOf(streamId);
        uint128 balanceAfter = balanceOf(streamId);
        
        // CRITICAL: Covered debt should not decrease from refund
        assert coveredAfter >= coveredBefore || balanceAfter < coveredBefore,
            "CRITICAL EXPLOIT: Refund stole covered debt from recipient";
            
        // CRITICAL: Can only reduce excess (balance - covered)
        assert to_mathint(balanceBefore) - to_mathint(coveredBefore) >= 
               to_mathint(balanceAfter) - to_mathint(coveredAfter),
            "CRITICAL EXPLOIT: Refund extracted more than excess balance";
    }
}

// ============================================================================
// CRITICAL EXPLOIT #3: Pause-Restart Rate Manipulation
// ============================================================================
// Check if pause-restart with different rate can manipulate debt accounting

rule exploit_rate_change_debt_manipulation(uint256 streamId, uint256 newRate) {
    env e1;
    env e2;
    
    require e1.block.timestamp < e2.block.timestamp;
    require !isVoided(streamId);
    require !isPaused(streamId);
    require newRate > 0;
    
    uint256 totalDebtBefore = totalDebtOf(streamId);
    uint128 coveredBefore = coveredDebtOf(streamId);
    uint128 balanceBefore = balanceOf(streamId);
    uint256 oldRate = getRatePerSecond(streamId);
    
    // Pause the stream
    pause(e1, streamId);
    uint256 debtAtPause = totalDebtOf(streamId);
    
    // Restart with new rate
    restart(e2, streamId, newRate);
    uint256 debtAfterRestart = totalDebtOf(streamId);
    
    // CRITICAL: Total debt should not decrease on restart
    assert debtAfterRestart >= debtAtPause,
        "CRITICAL EXPLOIT: Restart decreased total debt - rate manipulation";
        
    // CRITICAL: Covered debt should be consistent
    uint128 coveredAfterRestart = coveredDebtOf(streamId);
    assert to_mathint(coveredAfterRestart) <= to_mathint(balanceBefore),
        "CRITICAL EXPLOIT: Rate change manipulated covered debt beyond balance";
}

// ============================================================================
// CRITICAL EXPLOIT #4: Void After Withdraw
// ============================================================================
// Check if voiding after withdraw can double-spend or manipulate balances

rule exploit_void_after_withdraw_double_spend(uint256 streamId) {
    env e1;
    env e2;
    
    require !isVoided(streamId);
    require !isPaused(streamId);
    
    uint128 coveredBefore = coveredDebtOf(streamId);
    uint128 balanceBefore = balanceOf(streamId);
    address recipient = getRecipient(streamId);
    address token = getToken(streamId);
    
    require coveredBefore > 0;
    require balanceBefore >= coveredBefore;
    
    // Withdraw covered debt
    uint128 withdrawAmount = coveredBefore;
    withdraw(e1, streamId, recipient, withdrawAmount);
    
    uint128 balanceAfterWithdraw = balanceOf(streamId);
    uint128 coveredAfterWithdraw = coveredDebtOf(streamId);
    
    // Now void the stream
    void(e2, streamId);
    
    // Check if void manipulates balances
    assert isVoided(streamId),
        "CRITICAL EXPLOIT: Void did not mark stream as voided";
        
    // CRITICAL: Void should not allow further withdrawals
    withdraw@withrevert(e2, streamId, recipient, 1);
    assert lastReverted,
        "CRITICAL EXPLOIT: Can withdraw after void - double spend possible";
}

// ============================================================================
// CRITICAL EXPLOIT #5: Uncovered Debt Manipulation
// ============================================================================
// Check if uncovered debt can be manipulated to drain contract

rule exploit_uncovered_debt_calculation(uint256 streamId) {
    env e;
    
    require !isVoided(streamId);
    
    uint256 totalDebt = totalDebtOf(streamId);
    uint128 covered = coveredDebtOf(streamId);
    uint256 uncovered = uncoveredDebtOf(streamId);
    uint128 balance = balanceOf(streamId);
    
    // CRITICAL: Uncovered debt must equal totalDebt - coveredDebt
    assert to_mathint(totalDebt) == to_mathint(covered) + to_mathint(uncovered),
        "CRITICAL EXPLOIT: Debt accounting mismatch - manipulation possible";
        
    // CRITICAL: Covered debt cannot exceed balance
    assert covered <= balance,
        "CRITICAL EXPLOIT: Covered debt exceeds balance - insolvency";
        
    // CRITICAL: Uncovered debt means insufficient balance
    assert (uncovered > 0) => (balance < totalDebt),
        "CRITICAL EXPLOIT: Uncovered debt exists but balance covers total debt";
}

// ============================================================================
// CRITICAL EXPLOIT #6: Deposit Front-Running
// ============================================================================
// Check if attacker can front-run deposit to manipulate debt snapshots

rule exploit_deposit_front_running(uint256 streamId, uint128 depositAmount) {
    env e1;
    env e2;
    
    require e1.block.timestamp == e2.block.timestamp; // Same block
    require e1.msg.sender != e2.msg.sender; // Different callers
    require depositAmount > 0;
    require !isVoided(streamId);
    
    address attacker = e1.msg.sender;
    address victim = e2.msg.sender;
    address sender = getSender(streamId);
    address recipient = getRecipient(streamId);
    
    uint128 balanceBefore = balanceOf(streamId);
    uint256 totalDebtBefore = totalDebtOf(streamId);
    
    // Attacker withdraws first (front-runs)
    uint128 coveredBeforeAttack = coveredDebtOf(streamId);
    if (coveredBeforeAttack > 0) {
        withdraw(e1, streamId, recipient, coveredBeforeAttack);
    }
    
    // Victim deposits
    deposit(e2, streamId, depositAmount, sender, recipient);
    
    uint128 balanceAfter = balanceOf(streamId);
    uint128 coveredAfter = coveredDebtOf(streamId);
    
    // CRITICAL: Deposit should increase balance correctly
    assert to_mathint(balanceAfter) >= to_mathint(depositAmount),
        "CRITICAL EXPLOIT: Deposit did not increase balance - front-run attack";
}

// ============================================================================
// CRITICAL EXPLOIT #7: Time Manipulation in Debt Calculation
// ============================================================================
// Check if manipulating block.timestamp can cause issues

rule exploit_time_based_debt_manipulation(uint256 streamId) {
    env e1;
    env e2;
    
    require !isVoided(streamId);
    require !isPaused(streamId);
    require e2.block.timestamp > e1.block.timestamp;
    
    // Large time jump
    require to_mathint(e2.block.timestamp) - to_mathint(e1.block.timestamp) > 365 * 24 * 3600;
    
    uint256 debt1 = totalDebtOf(streamId);
    uint256 debt2 = totalDebtOf(streamId);
    
    uint256 ratePerSec = getRatePerSecond(streamId);
    require ratePerSec > 0;
    
    uint256 timeDelta = require_uint256(e2.block.timestamp - e1.block.timestamp);
    uint256 expectedDebtIncrease = ratePerSec * timeDelta;
    
    // CRITICAL: Debt increase should not overflow or wrap around
    assert to_mathint(debt2) >= to_mathint(debt1),
        "CRITICAL EXPLOIT: Debt decreased over time - overflow detected";
        
    // If debt didn't increase by at least some minimum, there's overflow
    assert debt2 >= debt1 + (expectedDebtIncrease > max_uint256 - debt1 ? 0 : expectedDebtIncrease) ||
           debt2 < expectedDebtIncrease, // Overflow occurred
        "CRITICAL EXPLOIT: Time manipulation caused unexpected debt calculation";
}

// ============================================================================
// CRITICAL EXPLOIT #8: Depletion Time Manipulation
// ============================================================================
// Check if depletion time can be manipulated to withdraw more than deserved

rule exploit_depletion_time_calculation(uint256 streamId) {
    env e;
    
    require !isVoided(streamId);
    require !isPaused(streamId);
    
    uint128 balance = balanceOf(streamId);
    uint256 ratePerSec = getRatePerSecond(streamId);
    uint256 depletionTime = depletionTimeOf(streamId);
    uint256 totalDebt = totalDebtOf(streamId);
    
    require ratePerSec > 0;
    require balance > 0;
    
    // CRITICAL: Depletion time should be when balance is exhausted
    // If depletionTime is in the future, then at that time, debt should equal total balance
    if (depletionTime > e.block.timestamp) {
        uint256 timeToDepletion = require_uint256(depletionTime - e.block.timestamp);
        uint256 futureDebt = totalDebt + (ratePerSec * timeToDepletion);
        
        // Balance should cover debt until depletion
        assert to_mathint(balance) >= to_mathint(totalDebt),
            "CRITICAL EXPLOIT: Depletion time calculation allows overdraft";
    }
}
