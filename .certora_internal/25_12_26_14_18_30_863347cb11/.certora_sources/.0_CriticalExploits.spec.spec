using SablierFlow as flow;

methods {
    // Core state queries
    function getBalance(uint256) external returns (uint128) envfree;
    function totalDebtOf(uint256) external returns (uint256) envfree;
    function coveredDebtOf(uint256) external returns (uint128) envfree;
    function uncoveredDebtOf(uint256) external returns (uint256) envfree;
    function refundableAmountOf(uint256) external returns (uint128) envfree;
    function ongoingDebtScaledOf(uint256) external returns (uint256) envfree;
    function depletionTimeOf(uint256) external returns (uint256) envfree;

    // Stream properties
    function getSnapshotTime(uint256) external returns (uint40) envfree;
    function getSnapshotDebtScaled(uint256) external returns (uint256) envfree;
    function isVoided(uint256) external returns (bool) envfree;
    function getSender(uint256) external returns (address) envfree;
    function getRecipient(uint256) external returns (address) envfree;

    // State-changing functions
    function deposit(uint256, uint128, address, address) external;
    function depositAndPause(uint256, uint128) external;
    function withdraw(uint256, address, uint128) external;
    function withdrawMax(uint256, address) external returns (uint128);
    function refund(uint256, uint128) external;
    function refundMax(uint256) external returns (uint128);
    function refundAndPause(uint256, uint128) external;
    function pause(uint256) external;
    // Note: restart/adjustRatePerSecond accept UD21x18, which is a user-defined type;
    // to avoid type conflicts in CVL, we omit their declarations and avoid direct calls in rules.
    // Alias Solidity's void(uint256) to avoid using the reserved token directly in rules.
    function voidStream(uint256) external => void(uint256);

    // ERC20
    function _.balanceOf(address) external => DISPATCHER(true);
    function _.transfer(address, uint256) external => DISPATCHER(true);
    function _.transferFrom(address, address, uint256) external => DISPATCHER(true);
}

// GHOST for tracking token balances
ghost mapping(address => mapping(address => uint256)) ghostTokenBalances;

// ============================================================================
// CRITICAL EXPLOIT #1: Integer Overflow in Debt Calculation
// ============================================================================
// If ongoingDebtScaledOf * (time - snapshotTime) * SCALE_FACTOR overflows,
// attacker can manipulate debt calculation to steal funds

rule exploit_debt_overflow_manipulation(uint256 streamId) {
    env e;

    require !isVoided(streamId);
    uint40 snapshotTime = getSnapshotTime(streamId);
    uint256 snapshotDebtScaled = getSnapshotDebtScaled(streamId);

    require e.block.timestamp > snapshotTime;
    uint256 timeDelta = require_uint256(e.block.timestamp - snapshotTime);

    // Check if multiplication could overflow
    uint256 scaledRate = ongoingDebtScaledOf(streamId);

    // If this overflows, totalDebt calculation is wrong
    uint256 maxDebt = max_uint256;
    require scaledRate > 0;
    require timeDelta > 0;

    uint256 totalDebtBefore = totalDebtOf(streamId);
    uint128 coveredBefore = coveredDebtOf(streamId);
    uint128 balanceBefore = getBalance(streamId);

    // Try to withdraw max when debt calculation might be corrupted
    uint128 withdrawAmount = coveredBefore;
    withdraw@withrevert(e, streamId, getSender(streamId), withdrawAmount);

    if (!lastReverted) {
        uint128 balanceAfter = getBalance(streamId);

        // CRITICAL: If we can withdraw more than we should, it's an exploit
        assert to_mathint(balanceBefore) >= to_mathint(withdrawAmount), "CRITICAL EXPLOIT: Withdrew more than balance - overflow detected";

        assert to_mathint(balanceAfter) == to_mathint(balanceBefore) - to_mathint(withdrawAmount), "CRITICAL EXPLOIT: Balance accounting broken - overflow detected";
    }
}

// ============================================================================
// CRITICAL EXPLOIT #2: Refund Can Steal Covered Debt
// ============================================================================
// Check if refund allows sender to extract funds that should go to recipient

rule exploit_refund_steals_covered_debt(uint256 streamId) {
    env e;

    require !isVoided(streamId);

    uint128 coveredBefore = coveredDebtOf(streamId);
    uint128 balanceBefore = getBalance(streamId);
    uint128 refundableBefore = refundableAmountOf(streamId);

    require coveredBefore > 0;
    require balanceBefore > coveredBefore; // There's excess to refund

    // Try to refund maximum

    uint128 refundAmount = refundableBefore;
    require refundAmount > 0;

    refund@withrevert(e, streamId, refundAmount);

    if (!lastReverted) {
        uint128 coveredAfter = coveredDebtOf(streamId);
        uint128 balanceAfter = getBalance(streamId);

        // CRITICAL: Covered debt should not decrease from refund
        assert coveredAfter >= coveredBefore || balanceAfter < coveredBefore, "CRITICAL EXPLOIT: Refund stole covered debt from recipient";

        // CRITICAL: Can only reduce excess (balance - covered)
        assert to_mathint(balanceBefore) - to_mathint(coveredBefore) >= to_mathint(balanceAfter) - to_mathint(coveredAfter), "CRITICAL EXPLOIT: Refund extracted more than excess balance";
    }
}

// ============================================================================
// CRITICAL EXPLOIT #3: Pause-Restart Rate Manipulation
// ============================================================================
// Check if pause-restart with different rate can manipulate debt accounting

// Adjusted: focus on pause effect without calling UD21x18-based restart
rule exploit_pause_debt_manipulation(uint256 streamId) {
    env e1;
    require !isVoided(streamId);

    uint256 totalDebtBefore = totalDebtOf(streamId);
    uint128 coveredBefore = coveredDebtOf(streamId);
    uint128 balanceBefore = getBalance(streamId);

    // Pause the stream
    pause(e1, streamId);
    uint256 debtAfterPause = totalDebtOf(streamId);

    // CRITICAL: Total debt should not decrease when pausing
    assert debtAfterPause >= totalDebtBefore, "CRITICAL EXPLOIT: Pause decreased total debt - manipulation";
}

// ============================================================================
// CRITICAL EXPLOIT #4: Void After Withdraw
// ============================================================================
// Check if voiding after withdraw can double-spend or manipulate balances

rule exploit_void_after_withdraw_double_spend(uint256 streamId) {
    env e1;
    env e2;

    require !isVoided(streamId);

    uint128 coveredBefore = coveredDebtOf(streamId);
    uint128 balanceBefore = getBalance(streamId);
    address recipient = getRecipient(streamId);

    require coveredBefore > 0;
    require balanceBefore >= coveredBefore;

    // Withdraw covered debt
    uint128 withdrawAmount = coveredBefore;
    withdraw(e1, streamId, recipient, withdrawAmount);

    uint128 balanceAfterWithdraw = getBalance(streamId);
    uint128 coveredAfterWithdraw = coveredDebtOf(streamId);

    // Now void the stream
    voidStream(e2, streamId);

    // Check if void manipulates balances
    assert isVoided(streamId), "CRITICAL EXPLOIT: Void did not mark stream as voided";

    // CRITICAL: Void should not allow further withdrawals
    withdraw@withrevert(e2, streamId, recipient, 1);
    assert lastReverted, "CRITICAL EXPLOIT: Can withdraw after void - double spend possible";
}

// ============================================================================
// CRITICAL EXPLOIT #5: Uncovered Debt Manipulation
// ============================================================================
// Check if uncovered debt can be manipulated to drain contract

rule exploit_uncovered_debt_calculation(uint256 streamId) {
    env e;

    require !isVoided(streamId);

    uint256 totalDebt = totalDebtOf(streamId);
    uint128 covered = coveredDebtOf(streamId);
    uint256 uncovered = uncoveredDebtOf(streamId);
    uint128 balance = getBalance(streamId);

    // CRITICAL: Uncovered debt must equal totalDebt - coveredDebt
    assert to_mathint(totalDebt) == to_mathint(covered) + to_mathint(uncovered), "CRITICAL EXPLOIT: Debt accounting mismatch - manipulation possible";

    // CRITICAL: Covered debt cannot exceed balance
    assert covered <= balance, "CRITICAL EXPLOIT: Covered debt exceeds balance - insolvency";

    // CRITICAL: Uncovered debt means insufficient balance
    assert (uncovered > 0) => (balance < totalDebt), "CRITICAL EXPLOIT: Uncovered debt exists but balance covers total debt";
}

// ============================================================================
// CRITICAL EXPLOIT #6: Deposit Front-Running
// ============================================================================
// Check if attacker can front-run deposit to manipulate debt snapshots

rule exploit_deposit_front_running(uint256 streamId, uint128 depositAmount) {
    env e1;
    env e2;

    require e1.block.timestamp == e2.block.timestamp; // Same block
    require e1.msg.sender != e2.msg.sender; // Different callers
    require depositAmount > 0;
    require !isVoided(streamId);

    address attacker = e1.msg.sender;
    address victim = e2.msg.sender;
    address sender = getSender(streamId);
    address recipient = getRecipient(streamId);

    uint128 balanceBefore = getBalance(streamId);
    uint256 totalDebtBefore = totalDebtOf(streamId);

    // Attacker withdraws first (front-runs)
    uint128 coveredBeforeAttack = coveredDebtOf(streamId);
    if (coveredBeforeAttack > 0) {
        withdraw(e1, streamId, recipient, coveredBeforeAttack);
    }

    // Victim deposits
    deposit(e2, streamId, depositAmount, sender, recipient);

    uint128 balanceAfter = getBalance(streamId);
    uint128 coveredAfter = coveredDebtOf(streamId);

    // CRITICAL: Deposit should increase balance correctly
    assert to_mathint(balanceAfter) >= to_mathint(depositAmount), "CRITICAL EXPLOIT: Deposit did not increase balance - front-run attack";
}

// ============================================================================
// CRITICAL EXPLOIT #7: Time Manipulation in Debt Calculation
// ============================================================================
// Check if manipulating block.timestamp can cause issues

rule exploit_time_based_debt_manipulation(uint256 streamId) {
    env e1;
    env e2;

    require !isVoided(streamId);
    require e2.block.timestamp > e1.block.timestamp;

    // Large time jump
    require to_mathint(e2.block.timestamp) - to_mathint(e1.block.timestamp) > 365 * 24 * 3600;

    uint256 debt1 = totalDebtOf(streamId);
    uint256 debt2 = totalDebtOf(streamId);

    // CRITICAL: Debt increase should not overflow or wrap around
    assert to_mathint(debt2) >= to_mathint(debt1), "CRITICAL EXPLOIT: Debt decreased over time - overflow detected";
}

// ============================================================================
// CRITICAL EXPLOIT #8: Depletion Time Manipulation
// ============================================================================
// Check if depletion time can be manipulated to withdraw more than deserved

rule exploit_depletion_time_calculation(uint256 streamId) {
    env e;

    require !isVoided(streamId);
    uint128 balance = getBalance(streamId);
    // Use ongoingDebtScaledOf to ensure the stream is active
    require ongoingDebtScaledOf(streamId) > 0;
    uint256 depletionTime = depletionTimeOf(streamId);
    uint256 totalDebt = totalDebtOf(streamId);
    require balance > 0;

    // CRITICAL: Depletion time should be when balance is exhausted
    // If depletionTime is in the future, then at that time, debt should equal total balance
    if (depletionTime > e.block.timestamp) {
        uint256 timeToDepletion = require_uint256(depletionTime - e.block.timestamp);
        // We cannot directly compute future debt without UD21x18 rate; rely on monotonicity checks

        // Balance should cover debt until depletion
        assert to_mathint(balance) >= to_mathint(totalDebt), "CRITICAL EXPLOIT: Depletion time calculation allows overdraft";
    }
}
